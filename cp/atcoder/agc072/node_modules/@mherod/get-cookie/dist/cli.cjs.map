{"version":3,"sources":["../src/core/cookies/cookieSpecsFromUrl.ts","../src/utils/argv.ts","../src/utils/logger.ts","../src/config.ts","../src/utils/logHelpers.ts","../src/cli/services/CookieQueryService.ts","../src/core/browsers/getEncryptedChromeCookie.ts","../src/core/browsers/chrome/ChromeApplicationSupport.ts","../src/core/browsers/QuerySqliteThenTransform.ts","../src/core/browsers/listChromeProfiles.ts","../src/core/browsers/chrome/decrypt.ts","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js","../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js","../src/core/browsers/chrome/getChromePassword.ts","../src/utils/execSimple.ts","../src/core/browsers/chrome/macos/getChromePassword.ts","../src/core/browsers/chrome/ChromeCookieQueryStrategy.ts","../src/utils/flatMapAsync.ts","../src/core/browsers/CompositeCookieQueryStrategy.ts","../src/core/browsers/firefox/FirefoxCookieQueryStrategy.ts","../src/core/browsers/safari/SafariCookieQueryStrategy.ts","../src/core/browsers/safari/BinaryCodableCookies.ts","../src/core/browsers/safari/BinaryCodableCookie.ts","../src/types/schemas.ts","../src/core/browsers/safari/BinaryCodablePage.ts","../src/core/browsers/safari/decodeBinaryCookies.ts","../src/cli/services/CookieStrategyFactory.ts","../src/cli/cliQueryCookies.ts","../src/cli/cli.ts"],"sourcesContent":["import type { CookieSpec } from \"../../types/schemas\";\n\n/**\n * Process a domain into cookie specifications, including parent domains\n * @internal\n * @param domain - The domain to process (e.g., 'api.example.com')\n * @returns Array of cookie specifications for the domain and its parents\n */\nfunction processDomainsIntoCookieSpecs(domain: string): CookieSpec[] {\n  const parts = domain.split(\".\");\n  const cookieSpecs: CookieSpec[] = [];\n\n  /**\n   * Add the full domain first to ensure exact matches are prioritized\n   * The '%' wildcard in the name field matches any cookie name for this domain\n   */\n  cookieSpecs.push({\n    name: \"%\",\n    domain: domain,\n  });\n\n  /**\n   * Add parent domains to support domain-level cookie matching\n   * For example, for 'sub.example.com', we also want to match 'example.com'\n   * This is important because cookies can be set at parent domain levels\n   */\n  for (let i = 1; i < parts.length - 1; i++) {\n    const subDomain = parts.slice(i).join(\".\");\n    cookieSpecs.push({\n      name: \"%\",\n      domain: subDomain,\n    });\n  }\n\n  return cookieSpecs;\n}\n\n/**\n * Generate cookie specifications from a URL by creating specs for both the exact domain\n * and its parent domains. This allows for proper cookie matching across domain levels.\n * @param url - The URL to generate cookie specs from (e.g., 'https://example.com' or just 'example.com')\n * @returns An array of cookie specifications for the URL and its parent domains\n * @remarks\n * - If the URL is provided without a protocol, it will first try to parse with 'https://' prefix\n * - If parsing fails, it will treat the input as a plain domain name\n * - The function handles invalid URLs gracefully by treating them as domain names\n * - The '%' wildcard is used for the name to match all cookies for the domain\n * @example\n * ```typescript\n * // Basic URL with protocol\n * cookieSpecsFromUrl('https://example.com')\n * // Returns: [{ name: '%', domain: 'example.com' }]\n *\n * // URL with subdomain\n * cookieSpecsFromUrl('https://api.example.com')\n * // Returns: [\n * //   { name: '%', domain: 'api.example.com' },\n * //   { name: '%', domain: 'example.com' }\n * // ]\n *\n * // Domain without protocol (automatically handled)\n * cookieSpecsFromUrl('example.com')\n * // Returns: [{ name: '%', domain: 'example.com' }]\n * ```\n */\nexport function cookieSpecsFromUrl(url: string): CookieSpec[] {\n  // For URLs without protocol, try adding https://\n  if (!url.includes(\"://\")) {\n    try {\n      return cookieSpecsFromUrl(`https://${url}`);\n    } catch {\n      // If adding protocol fails, treat as domain name\n      return [\n        {\n          name: \"%\",\n          domain: url,\n        },\n      ];\n    }\n  }\n\n  try {\n    const urlObj = new URL(url);\n    return processDomainsIntoCookieSpecs(urlObj.hostname);\n  } catch (_error) {\n    /**\n     * Fallback handling for any parsing errors\n     * This ensures the function remains robust even with invalid input\n     * Returns a single spec treating the entire input as a domain name\n     */\n    return [\n      {\n        name: \"%\",\n        domain: url,\n      },\n    ];\n  }\n}\n","import minimist from \"minimist\";\n\n/**\n * Interface representing parsed command line arguments.\n * @property values - Record of option values parsed from command line\n * @property positionals - Array of positional arguments\n * @example\n * ```typescript\n * const args: ParsedArgs = {\n *   values: {\n *     browser: 'chrome',\n *     profile: 'default',\n *     verbose: true\n *   },\n *   positionals: ['script.js', 'input.txt']\n * }\n * ```\n */\ninterface ParsedArgs {\n  /** Record of option values parsed from command line */\n  values: Record<string, string | boolean | string[]>;\n  /** Array of positional arguments */\n  positionals: string[];\n}\n\n/**\n * Parses command line arguments into a structured format.\n * @internal\n * @param argv - Array of command line arguments to parse\n * @returns Parsed command line arguments object\n * @example\n * ```typescript\n * // Basic usage\n * const args = parseArgv(['--browser', 'chrome', '--verbose', 'script.js']);\n * // Returns: { values: { browser: 'chrome', verbose: true }, positionals: ['script.js'] }\n *\n * // Using short options\n * const args = parseArgv(['-b', 'firefox', '-v', 'script.js']);\n * // Returns: { values: { browser: 'firefox', verbose: true }, positionals: ['script.js'] }\n *\n * // Error handling\n * const args = parseArgv(['--invalid']); // Will throw error for unknown option\n * ```\n */\nexport function parseArgv(argv: string[]): ParsedArgs {\n  const parsed = minimist(argv, {\n    string: [\"browser\", \"profile\", \"url\", \"domain\", \"name\", \"output\", \"store\"],\n    boolean: [\n      \"help\",\n      \"version\",\n      \"verbose\",\n      \"dump\",\n      \"dump-grouped\",\n      \"render\",\n      \"render-grouped\",\n    ],\n    alias: {\n      b: \"browser\",\n      p: \"profile\",\n      u: \"url\",\n      d: \"domain\",\n      n: \"name\",\n      h: \"help\",\n      v: \"version\",\n      D: \"dump-grouped\",\n      r: \"render\",\n      R: \"render-grouped\",\n    },\n  });\n\n  const { _, ...values } = parsed;\n  return { values, positionals: _ };\n}\n","import { type ConsolaInstance, createConsola } from \"consola\";\n\nimport { env } from \"../config\";\n\n/**\n * Standard log levels and their usage:\n * - debug: Detailed information for debugging\n * - info: General operational information\n * - success: Successful operations\n * - warn: Warning conditions\n * - error: Error conditions that might still allow the app to continue\n * - fatal: Critical errors that prevent the app from continuing\n */\nconst consola = createConsola({\n  fancy: true,\n  formatOptions: {\n    showLogLevel: false,\n    colors: true,\n    date: false,\n    compact: true,\n    columns:\n      typeof process.stdout.columns === \"number\" ? process.stdout.columns : 80,\n  },\n  level: env.LOG_LEVEL === \"debug\" ? 5 : 2,\n});\n\n/**\n * Indicates whether debug logging is enabled\n * @example\n * if (isDebug) {\n *   logger.debug(\"Detailed debugging information\");\n * }\n */\nexport const isDebug = env.LOG_LEVEL === \"debug\";\n\n/**\n * Configured logger instance with standardized formatting and colored output.\n * Used for consistent logging throughout the application.\n * @example\n * // Basic usage\n * logger.info('Operation started');\n * logger.success('Task completed');\n * logger.error('Failed to process', error);\n *\n * // Tagged logging for module context\n * const moduleLogger = logger.withTag('ModuleName');\n * moduleLogger.info('Module specific log');\n *\n * // Structured logging\n * logger.info('User action', {\n *   userId: '123',\n *   action: 'login',\n *   timestamp: new Date()\n * });\n *\n * // Error logging with full context\n * logger.error('Operation failed', {\n *   error: error,\n *   context: 'operation name',\n *   input: data\n * });\n */\nconst logger: ConsolaInstance = consola;\n\n/**\n *\n */\nexport default logger;\n","import { homedir } from \"os\";\n\nimport { config } from \"dotenv\";\nimport { z } from \"zod\";\n\n// Load environment variables from .env file\nconfig();\n\nconst EnvironmentSchema = z.object({\n  LOG_LEVEL: z.enum([\"debug\", \"info\", \"warn\", \"error\"]).default(\"info\"),\n  HOME: z\n    .string()\n    .optional()\n    .transform((val) => val ?? process.env.USERPROFILE ?? \"\")\n    .pipe(z.string().min(1)),\n});\n\n/**\n * Validated environment variables with type safety and fallbacks\n * @example\n * // Using the environment variables\n * if (env.LOG_LEVEL === \"debug\") {\n *   console.log(\"Debug mode enabled\");\n * }\n *\n * // Accessing home directory\n * const cookiePath = join(env.HOME, \"Library/Cookies\");\n */\nexport const env = EnvironmentSchema.parse({\n  LOG_LEVEL: process.env.LOG_LEVEL,\n  HOME: homedir(),\n});\n","import { type ConsolaInstance } from \"consola\";\n\nimport logger from \"./logger\";\n\n/**\n * Helper functions for common logging patterns.\n * @module\n * @example\n * ```typescript\n * import { logOperationResult, logError } from './logHelpers';\n *\n * try {\n *   const result = await someOperation();\n *   logOperationResult('Operation', true, { data: result });\n * } catch (error) {\n *   logError('Operation failed', error);\n * }\n * ```\n */\n\ninterface OperationContext {\n  [key: string]: unknown;\n}\n\n/**\n * Log the result of an operation with consistent formatting\n * @param operation - The name of the operation\n * @param success - Whether the operation was successful\n * @param context - Additional context to log\n */\nexport function logOperationResult(\n  operation: string,\n  success: boolean,\n  context?: OperationContext,\n): void {\n  if (success) {\n    logger.success(`${operation} succeeded`, context);\n  } else {\n    logger.error(`${operation} failed`, context);\n  }\n}\n\n/**\n * Log an error with consistent formatting\n * @param message - The error message\n * @param error - The error object\n * @param context - Additional context to log\n */\nexport function logError(\n  message: string,\n  error: unknown,\n  context?: OperationContext,\n): void {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  logger.error(message, { ...context, error: errorMessage });\n}\n\n/**\n * Log a warning with consistent formatting\n * @param component - The component generating the warning\n * @param message - The warning message\n * @param context - Additional context to log\n */\nexport function logWarn(\n  component: string,\n  message: string,\n  context?: OperationContext,\n): void {\n  logger.warn(`[${component}] ${message}`, context);\n}\n\n/**\n * Create a logger instance with a component tag\n * @param component - The component name to tag logs with\n * @returns A logger instance that prefixes all messages with the component tag\n * @example\n * ```typescript\n * const dbLogger = createTaggedLogger('Database');\n * dbLogger.info('Connection established');\n * ```\n */\nexport function createTaggedLogger(component: string): ConsolaInstance {\n  return logger.withTag(component);\n}\n\n// Re-export the base logger for direct usage\n/**\n * Re-export of the base logger for direct usage.\n */\nexport { default as logger } from \"./logger\";\n","import type {\n  CookieSpec,\n  ExportedCookie,\n  CookieQueryOptions,\n} from \"../../types/schemas\";\n\nimport type { CookieQueryStrategy } from \"./CookieStrategyFactory\";\n\n/**\n * Service for querying cookies using a strategy\n */\nexport class CookieQueryService {\n  /**\n   * Creates a new CookieQueryService instance\n   * @param strategy - The strategy to use for querying cookies\n   */\n  public constructor(private readonly strategy: CookieQueryStrategy) {}\n\n  /**\n   * Queries cookies from the strategy with options\n   * @param spec - The cookie specification to query for\n   * @param options - Query options including limit, removeExpired, and store path\n   * @returns Array of exported cookies\n   */\n  public async queryCookies(\n    spec: CookieSpec,\n    options?: CookieQueryOptions,\n  ): Promise<ExportedCookie[]> {\n    return this.strategy.queryCookies(spec.name, spec.domain, options?.store);\n  }\n}\n","import { existsSync } from \"fs\";\nimport { join } from \"path\";\n\nimport glob from \"fast-glob\";\n\nimport {\n  logError,\n  logOperationResult,\n  createTaggedLogger,\n} from \"@utils/logHelpers\";\n\nimport type { CookieRow } from \"../../types/schemas\";\n\nimport { chromeApplicationSupport } from \"./chrome/ChromeApplicationSupport\";\nimport { querySqliteThenTransform } from \"./QuerySqliteThenTransform\";\n\nconst logger = createTaggedLogger(\"getEncryptedChromeCookie\");\n\ninterface ChromeCookieRow {\n  encrypted_value: Buffer;\n  name: string;\n  host_key: string;\n  expires_utc: number;\n}\n\ninterface GetEncryptedCookieOptions {\n  name: string;\n  domain: string;\n  file?: string;\n}\n\ninterface SqlQuery {\n  sql: string;\n  params: string[];\n}\n\n/**\n * Validates if a path is a valid, existing file\n * @param path - Path to validate\n * @returns true if path is valid and file exists, false otherwise\n */\nfunction isValidFilePath(path: unknown): path is string {\n  if (typeof path !== \"string\") {\n    return false;\n  }\n\n  const trimmedPath = path.trim();\n  if (trimmedPath.length === 0) {\n    return false;\n  }\n\n  return existsSync(trimmedPath);\n}\n\n/**\n * Get paths to Chrome cookie files\n * @returns A promise that resolves to an array of file paths\n */\nasync function getCookieFiles(): Promise<string[]> {\n  const patterns = [\n    join(chromeApplicationSupport, \"Default/Cookies\"),\n    join(chromeApplicationSupport, \"Profile */Cookies\"),\n    join(chromeApplicationSupport, \"Profile Default/Cookies\"),\n  ];\n\n  const files: string[] = [];\n  for (const pattern of patterns) {\n    const matches = await glob(pattern);\n    files.push(...matches);\n  }\n\n  logger.debug(\"ChromeCookies\", \"Found cookie files\", {\n    count: files.length,\n    files,\n  });\n  return files;\n}\n\n/**\n * Builds the SQL query for retrieving cookies\n * @param name - Cookie name to search for\n * @param domain - Domain to filter by\n * @returns SQL query and parameters\n */\nfunction buildSqlQuery(name: string, domain: string): SqlQuery {\n  const isWildcard = name === \"%\";\n  const sql = isWildcard\n    ? `SELECT name, encrypted_value, host_key, expires_utc FROM cookies WHERE host_key LIKE ?`\n    : `SELECT name, encrypted_value, host_key, expires_utc FROM cookies WHERE name = ? AND host_key LIKE ?`;\n  const params = isWildcard ? [`%${domain}%`] : [name, `%${domain}%`];\n\n  return { sql, params };\n}\n\n/**\n * Processes a single cookie file to extract matching cookies\n * @param cookieFile - Path to the cookie file\n * @param name - Cookie name to search for\n * @param domain - Domain to filter by\n * @returns Array of matching cookies\n */\nasync function processCookieFile(\n  cookieFile: string,\n  name: string,\n  domain: string,\n): Promise<CookieRow[]> {\n  try {\n    const { sql, params } = buildSqlQuery(name, domain);\n    logger.debug(\"ChromeCookies\", \"Executing query\", { sql, params });\n\n    const rows = await querySqliteThenTransform<ChromeCookieRow, CookieRow>({\n      file: cookieFile,\n      sql,\n      params,\n      rowTransform: (row: ChromeCookieRow): CookieRow => ({\n        name: row.name,\n        domain: row.host_key,\n        value: row.encrypted_value,\n        expiry: row.expires_utc,\n      }),\n    });\n\n    logOperationResult(\"QueryCookies\", true, {\n      file: cookieFile,\n      count: rows.length,\n    });\n    return rows;\n  } catch (error) {\n    logError(\"Failed to read cookie file\", error, { file: cookieFile });\n    return [];\n  }\n}\n\n/**\n * Retrieve encrypted cookies from Chrome's cookie store\n * @param options - Options for querying Chrome cookies\n * @param options.name - The name of the cookie to retrieve\n * @param options.domain - The domain to retrieve cookies from\n * @param options.file - Optional specific cookie file to query\n * @returns Promise resolving to array of encrypted cookies\n */\nexport async function getEncryptedChromeCookie({\n  name,\n  domain,\n  file,\n}: GetEncryptedCookieOptions): Promise<CookieRow[]> {\n  const cookieFiles =\n    typeof file === \"string\" && file.length > 0\n      ? [file]\n      : await getCookieFiles();\n\n  if (cookieFiles.length === 0) {\n    logger.debug(\"ChromeCookies\", \"No cookie files found\");\n    return [];\n  }\n\n  const results: CookieRow[] = [];\n  for (const cookieFile of cookieFiles) {\n    if (!isValidFilePath(cookieFile)) {\n      logger.debug(\"ChromeCookies\", \"Cookie file missing or invalid\", {\n        file: cookieFile,\n      });\n      continue;\n    }\n\n    const cookies = await processCookieFile(cookieFile, name, domain);\n    results.push(...cookies);\n  }\n\n  logger.debug(\"ChromeCookies\", \"Query complete\", {\n    totalCookies: results.length,\n  });\n  return results;\n}\n","import { homedir } from \"os\";\nimport { join } from \"path\";\n\n/**\n * The path to Chrome's application support directory on macOS\n * This constant is used to locate Chrome's profile and cookie storage directories\n * @throws {Error} If unable to determine user's home directory\n */\nexport const chromeApplicationSupport = (() => {\n  const home = homedir();\n  if (!home) {\n    throw new Error(\"Unable to determine user home directory\");\n  }\n  return join(home, \"Library\", \"Application Support\", \"Google\", \"Chrome\");\n})();\n","// External imports\nimport BetterSqlite3, { Database } from \"better-sqlite3\";\n\n// Internal imports\nimport { logError } from \"@utils/logHelpers\";\n\ninterface QuerySqliteThenTransformOptions<TRow, TResult> {\n  file: string;\n  sql: string;\n  params?: unknown[];\n  rowFilter?: (row: TRow) => boolean;\n  rowTransform?: (row: TRow) => TResult;\n}\n\nfunction openDatabase(file: string): Database {\n  try {\n    return new BetterSqlite3(file, { readonly: true, fileMustExist: true });\n  } catch (error) {\n    logError(\"Database open failed\", error, { file });\n    throw error;\n  }\n}\n\nfunction closeDatabase(db: Database): Promise<void> {\n  try {\n    db.close();\n    return Promise.resolve();\n  } catch (error) {\n    logError(\"Database close failed\", error);\n    return Promise.reject(\n      error instanceof Error\n        ? error\n        : new Error(\"Failed to close database: Unknown error\"),\n    );\n  }\n}\n\n/**\n * Executes a SQL query on a SQLite database file and transforms the results\n * @param root0 - The options object containing query parameters\n * @param root0.file - The path to the SQLite database file\n * @param root0.sql - The SQL query to execute\n * @param root0.params - Optional parameters for the SQL query\n * @param root0.rowFilter - Optional function to filter rows from the result set\n * @param root0.rowTransform - Optional function to transform each row before returning\n * @returns A promise that resolves to an array of transformed results\n */\nexport async function querySqliteThenTransform<TRow, TResult>({\n  file,\n  sql,\n  params,\n  rowFilter,\n  rowTransform,\n}: QuerySqliteThenTransformOptions<TRow, TResult>): Promise<TResult[]> {\n  let db: Database | undefined;\n\n  try {\n    db = openDatabase(file);\n    const stmt = db.prepare(sql);\n    const rows = stmt.all(params) as TRow[];\n\n    const filteredRows = rowFilter ? rows.filter(rowFilter) : rows;\n    const transformedRows = rowTransform\n      ? filteredRows.map(rowTransform)\n      : (filteredRows as unknown as TResult[]);\n\n    return transformedRows;\n  } catch (error) {\n    logError(\"Database query failed\", error, { file, sql });\n    throw error;\n  } finally {\n    if (db) {\n      await closeDatabase(db);\n    }\n  }\n}\n","// External imports\nimport { readFileSync } from \"fs\";\nimport { join } from \"path\";\n\nimport fg from \"fast-glob\";\n\n// Internal imports\nimport { createTaggedLogger } from \"../../utils/logHelpers\";\n\nimport { chromeApplicationSupport } from \"./chrome/ChromeApplicationSupport\";\n\nconst logger = createTaggedLogger(\"listChromeProfiles\");\n\n/**\n * Lists all Chrome profile paths that contain cookie files\n * @internal\n * @returns An array of absolute paths to Chrome cookie files\n * @throws {Error} If Chrome's application support directory cannot be accessed\n * @example\n * ```typescript\n * // Get all Chrome cookie file paths\n * const cookiePaths = listChromeProfilePaths();\n * // Returns: [\n * //   '/Users/name/Library/Application Support/Chrome/Profile 1/Cookies',\n * //   '/Users/name/Library/Application Support/Chrome/Profile 2/Cookies'\n * // ]\n *\n * // Handle errors\n * try {\n *   const paths = listChromeProfilePaths();\n * } catch (error) {\n *   logger.error('Failed to access Chrome profiles', { error });\n * }\n * ```\n */\nexport function listChromeProfilePaths(): string[] {\n  const files: string[] = fg.sync(`./**/Cookies`, {\n    cwd: chromeApplicationSupport,\n    absolute: true,\n  });\n\n  logger.debug(\"Found cookie files:\", files);\n  return files;\n}\n\n/**\n * Chrome Local State file structure\n * @internal\n */\ninterface ChromeLocalState {\n  profile: {\n    info_cache: Record<string, ChromeProfileInfo>;\n  };\n}\n\n/**\n * Chrome profile information structure\n * @property {string} name - The name of the profile\n * @property {number} active_time - Unix timestamp of last profile activity\n * @property {string} account_id - Unique identifier for the Chrome profile\n * @property {Record<string, unknown>} accountcapabilities - Account feature flags\n * @property {string} email - User's email address\n * @property {string} full_name - User's full name\n * @property {boolean} is_using_default_avatar - Whether using default profile picture\n * @property {boolean} is_using_default_name - Whether using default profile name\n * @property {string} last_downloaded_gaia_picture_url_with_size - Profile picture URL\n * @property {string} local_auth_credentials - Authentication credentials\n * @property {string} shortcut_name - Profile shortcut name\n * @property {string} user_name - Username associated with profile\n */\ninterface ChromeProfileInfo {\n  /** The name of the profile */\n  name: string;\n  /** Unix timestamp of last profile activity */\n  active_time: number;\n  /** Unique identifier for the Chrome profile */\n  account_id: string;\n  /** Account feature flags */\n  accountcapabilities: Record<string, unknown>;\n  /** User's email address */\n  email: string;\n  /** User's full name */\n  full_name: string;\n  /** Whether using default profile picture */\n  is_using_default_avatar: boolean;\n  /** Whether using default profile name */\n  is_using_default_name: boolean;\n  /** Profile picture URL */\n  last_downloaded_gaia_picture_url_with_size: string;\n  /** Authentication credentials */\n  local_auth_credentials: string;\n  /** Profile shortcut name */\n  shortcut_name: string;\n  /** Username associated with profile */\n  user_name: string;\n}\n\n/**\n * Lists all Chrome profiles and their associated information\n * @internal\n * @returns An array of Chrome profile information objects. Returns empty array if profiles cannot be read\n * @throws {Error} If Chrome's application support directory cannot be accessed\n * @example\n * ```typescript\n * // Get all Chrome profiles\n * const profiles = listChromeProfiles();\n * // Returns: [\n * //   {\n * //     name: \"Default\",\n * //     email: \"user@example.com\",\n * //     full_name: \"John Doe\",\n * //     ...\n * //   },\n * //   ...\n * // ]\n *\n * // Handle empty or error case\n * const profiles = listChromeProfiles();\n * if (profiles.length === 0) {\n *   logger.warn('No Chrome profiles found');\n * }\n * ```\n */\nexport function listChromeProfiles(): ChromeProfileInfo[] {\n  try {\n    const localStatePath = join(chromeApplicationSupport, \"Local State\");\n    const localState = JSON.parse(\n      readFileSync(localStatePath, \"utf8\"),\n    ) as ChromeLocalState;\n    return Object.values(localState.profile.info_cache);\n  } catch (error) {\n    logger.debug(\"Failed to access Chrome profiles\", { error });\n    return [];\n  }\n}\n","// External imports\nimport { createDecipheriv, pbkdf2 } from \"crypto\";\n\nimport { memoize } from \"lodash-es\";\n\n/**\n * Removes the v10 prefix from the encrypted value if present\n * @param value - The encrypted value\n * @returns The value without the v10 prefix\n */\nconst removeV10Prefix = memoize(\n  (value: Buffer): Buffer => {\n    if (\n      value.length >= 3 &&\n      value[0] === 0x76 && // 'v'\n      value[1] === 0x31 && // '1'\n      value[2] === 0x30\n    ) {\n      // '0'\n      return value.slice(3);\n    }\n    return value;\n  },\n  (value: Buffer) => value.toString(\"hex\"),\n);\n\n/**\n * Removes PKCS7 padding from the decrypted value\n * @param decrypted - The decrypted buffer\n * @returns The buffer without padding\n */\nconst removePadding = memoize(\n  (decrypted: Buffer): Buffer => {\n    const padding = decrypted[decrypted.length - 1];\n    if (padding && padding <= 16) {\n      return decrypted.slice(0, -padding);\n    }\n    return decrypted;\n  },\n  (decrypted: Buffer) => decrypted.toString(\"hex\"),\n);\n\n/**\n * Extracts the actual value from the decoded string by removing Chrome's prefixes\n * @param decodedString - The decoded string to clean up\n * @returns The cleaned up value\n */\nfunction extractValue(decodedString: string): string {\n  const cleanupPatterns = [\n    /.*?0t(.+)$/, // Pattern ending in \"0t\" followed by value\n    /.*?1e`(.+)$/, // Pattern ending in \"1e`\" followed by value\n    /.*?[`'](.+)$/, // Any backtick or quote followed by value\n    /[^\\x20-\\x7E]*([\\x20-\\x7E].+)$/, // Non-printable chars followed by printable chars\n  ];\n\n  for (const pattern of cleanupPatterns) {\n    const match = decodedString.match(pattern);\n    const value = match?.[1] ?? \"\";\n    if (value.length > 0) {\n      return value;\n    }\n  }\n  return decodedString;\n}\n\n/**\n * Decrypts Chrome's encrypted cookie values\n * @param encryptedValue - The encrypted cookie value as a Buffer\n * @param password - The Chrome encryption password\n * @returns A promise that resolves to the decrypted cookie value\n * @throws {Error} If decryption fails\n * @example\n */\nexport async function decrypt(\n  encryptedValue: Buffer,\n  password: string,\n): Promise<string> {\n  if (typeof password !== \"string\") {\n    throw new Error(\"password must be a string\");\n  }\n  if (!Buffer.isBuffer(encryptedValue)) {\n    throw new Error(\"encryptedData must be a Buffer\");\n  }\n\n  return new Promise((resolve, reject) => {\n    pbkdf2(password, \"saltysalt\", 1003, 16, \"sha1\", (error, key) => {\n      try {\n        if (error) {\n          reject(new Error(\"Failed to derive key: \" + error.message));\n          return;\n        }\n\n        const value = removeV10Prefix(encryptedValue);\n        if (value.length % 16 !== 0) {\n          reject(new Error(\"Encrypted data length is not a multiple of 16\"));\n          return;\n        }\n\n        // Chrome's encryption parameters\n        const iv = Buffer.alloc(16, \" \"); // 16 spaces\n        const decipher = createDecipheriv(\"aes-128-cbc\", key, iv);\n        decipher.setAutoPadding(false);\n\n        // Decrypt the value\n        let decrypted = decipher.update(value);\n        try {\n          decipher.final();\n        } catch (e) {\n          reject(\n            new Error(\"Failed to finalize decryption: \" + (e as Error).message),\n          );\n          return;\n        }\n\n        decrypted = removePadding(decrypted);\n        const decodedString = decrypted.toString(\"utf8\");\n        resolve(extractValue(decodedString));\n      } catch (e) {\n        reject(new Error(\"Decryption failed: \" + (e as Error).message));\n      }\n    });\n  });\n}\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n","import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n","import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n","import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n","import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n","import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n","import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n","import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n","import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n","import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n","import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n","import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n","import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n","import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n","import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n","import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n","import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n","import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n","import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n","import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n","import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n","import { platform } from \"os\";\n\nimport { getChromePassword as getMacOSPassword } from \"./macos/getChromePassword\";\n\n/**\n * Gets the Chrome Safe Storage password for the current platform.\n * This password is used to decrypt cookies stored in Chrome's cookie database.\n * Currently only supports macOS, where the password is stored in the system keychain.\n * @returns A promise that resolves to the Chrome Safe Storage password\n * @throws {Error} If the password cannot be retrieved or the platform is not supported\n */\nexport async function getChromePassword(): Promise<string> {\n  switch (platform()) {\n    case \"darwin\": {\n      return getMacOSPassword();\n    }\n    default:\n      throw new Error(`Platform ${platform()} is not supported`);\n  }\n}\n","// External imports\nimport { exec, ExecOptions } from \"child_process\";\nimport { promisify } from \"util\";\n\n// Internal imports\nimport { logError } from \"./logHelpers\";\n\nconst execPromise = promisify(exec);\n\n/**\n * Custom error class for command execution failures.\n * @property {string} command - The command that failed to execute\n * @property {Error} [originalError] - The underlying error that caused the failure\n * @throws CommandExecutionError Always throws with appropriate error context\n * @example\n * ```typescript\n * throw new CommandExecutionError(\n *   'Command timed out',\n *   'git status',\n *   originalError\n * );\n * ```\n */\nclass CommandExecutionError extends Error {\n  public constructor(\n    message: string,\n    public readonly command: string,\n    public readonly originalError?: Error,\n  ) {\n    super(message);\n    this.name = \"CommandExecutionError\";\n  }\n}\n\n/**\n * Executes a shell command and returns its output.\n * @param command - The command to execute\n * @param options - Optional execution options\n * @returns Promise resolving to command output\n * @throws CommandExecutionError if execution fails\n * @example\n * ```typescript\n * try {\n *   const { stdout } = await execSimple('git status');\n *   logger.info('Git status:', stdout);\n * } catch (error) {\n *   if (error instanceof CommandExecutionError) {\n *     logger.error('Git command failed:', error.message);\n *   }\n * }\n * ```\n */\nexport async function execSimple(\n  command: string,\n  options?: ExecOptions,\n): Promise<{ stdout: string; stderr: string }> {\n  try {\n    const result = await execPromise(command, {\n      ...options,\n      encoding: \"utf8\",\n    });\n    return {\n      stdout: result.stdout.toString(),\n      stderr: result.stderr.toString(),\n    };\n  } catch (error) {\n    logError(\"Command execution failed\", error, { command });\n    throw new CommandExecutionError(\n      error instanceof Error ? error.message : String(error),\n      command,\n      error instanceof Error ? error : undefined,\n    );\n  }\n}\n","import { execSimple } from \"../../../../utils/execSimple\";\n\n/**\n * Retrieves the Chrome Safe Storage password from the macOS keychain\n * @returns A promise that resolves to the Chrome Safe Storage password\n * @throws {Error} If the password cannot be retrieved from the keychain\n */\nexport async function getChromePassword(): Promise<string> {\n  const command = 'security find-generic-password -w -s \"Chrome Safe Storage\"';\n  const result = await execSimple(command);\n  return result.stdout.trim();\n}\n","import { createTaggedLogger, logError } from \"@utils/logHelpers\";\n\nimport {\n  BrowserName,\n  CookieQueryStrategy,\n  CookieRow,\n  ExportedCookie,\n} from \"../../../types/schemas\";\nimport { getEncryptedChromeCookie } from \"../getEncryptedChromeCookie\";\nimport { listChromeProfilePaths } from \"../listChromeProfiles\";\n\nimport { decrypt } from \"./decrypt\";\nimport { getChromePassword } from \"./getChromePassword\";\n\ninterface DecryptionContext {\n  file: string;\n  password: string;\n}\n\nfunction getExpiryDate(expiry: number | undefined | null): Date | \"Infinity\" {\n  if (typeof expiry !== \"number\" || expiry <= 0) {\n    return \"Infinity\";\n  }\n  return new Date(expiry);\n}\n\nfunction createExportedCookie(\n  domain: string,\n  name: string,\n  value: string,\n  expiry: number | undefined | null,\n  file: string,\n  decrypted: boolean,\n): ExportedCookie {\n  return {\n    domain,\n    name,\n    value,\n    expiry: getExpiryDate(expiry),\n    meta: {\n      file,\n      browser: \"Chrome\",\n      decrypted,\n    },\n  };\n}\n\n/**\n * Strategy for querying cookies from Chrome browser\n * @example\n * ```typescript\n * const strategy = new ChromeCookieQueryStrategy();\n * const cookies = await strategy.queryCookies('session', 'example.com');\n * ```\n */\nexport class ChromeCookieQueryStrategy implements CookieQueryStrategy {\n  private readonly logger = createTaggedLogger(\"ChromeCookieQueryStrategy\");\n\n  /**\n   * The browser name for this strategy\n   */\n  public readonly browserName: BrowserName = \"Chrome\";\n\n  /**\n   * Queries cookies from Chrome's cookie store\n   * @param name - The name pattern to match cookies against\n   * @param domain - The domain pattern to match cookies against\n   * @param store - Optional path to a specific cookie store file\n   * @returns A promise that resolves to an array of exported cookies\n   * @example\n   * ```typescript\n   * const strategy = new ChromeCookieQueryStrategy();\n   * const cookies = await strategy.queryCookies('session', 'example.com');\n   * console.log(cookies);\n   * ```\n   */\n  public async queryCookies(\n    name: string,\n    domain: string,\n    store?: string,\n  ): Promise<ExportedCookie[]> {\n    try {\n      this.logger.info(\"Querying cookies\", { name, domain, store });\n\n      if (process.platform !== \"darwin\") {\n        this.logger.warn(\"Platform not supported\", {\n          platform: process.platform,\n        });\n        return [];\n      }\n\n      const cookieFiles = store ?? listChromeProfilePaths();\n      const files = Array.isArray(cookieFiles) ? cookieFiles : [cookieFiles];\n      if (files.length === 0) {\n        this.logger.warn(\"No Chrome cookie files found\");\n        return [];\n      }\n\n      const password = await getChromePassword();\n      const results = await Promise.all(\n        files.map((file) => this.processFile(file, name, domain, password)),\n      );\n\n      return results.flat();\n    } catch (error) {\n      if (error instanceof Error) {\n        logError(\"Failed to query cookies\", error, { name, domain });\n      } else {\n        logError(\"Failed to query cookies\", new Error(String(error)), {\n          name,\n          domain,\n        });\n      }\n      return [];\n    }\n  }\n\n  private async processFile(\n    file: string,\n    name: string,\n    domain: string,\n    password: string,\n  ): Promise<ExportedCookie[]> {\n    try {\n      const encryptedCookies = await getEncryptedChromeCookie({\n        name,\n        domain,\n        file,\n      });\n\n      const context: DecryptionContext = { file, password };\n      const results = await Promise.allSettled(\n        encryptedCookies.map((cookie) => this.processCookie(cookie, context)),\n      );\n\n      return results\n        .map((result) => (result.status === \"fulfilled\" ? result.value : null))\n        .filter((cookie): cookie is ExportedCookie => cookie !== null);\n    } catch (error) {\n      if (error instanceof Error) {\n        this.logger.error(\"Failed to process cookie file\", { error, file });\n      } else {\n        this.logger.error(\"Failed to process cookie file\", {\n          error: String(error),\n          file,\n        });\n      }\n      return [];\n    }\n  }\n\n  private async processCookie(\n    cookie: CookieRow,\n    context: DecryptionContext,\n  ): Promise<ExportedCookie> {\n    try {\n      const value = Buffer.isBuffer(cookie.value)\n        ? cookie.value\n        : Buffer.from(String(cookie.value));\n\n      const decryptedValue = await decrypt(value, context.password);\n      return createExportedCookie(\n        cookie.domain,\n        cookie.name,\n        decryptedValue,\n        cookie.expiry,\n        context.file,\n        true,\n      );\n    } catch (error) {\n      if (error instanceof Error) {\n        this.logger.warn(\"Failed to decrypt cookie\", { error });\n      } else {\n        this.logger.warn(\"Failed to decrypt cookie\", { error: String(error) });\n      }\n      return createExportedCookie(\n        cookie.domain,\n        cookie.name,\n        cookie.value.toString(\"utf-8\"),\n        cookie.expiry,\n        context.file,\n        false,\n      );\n    }\n  }\n}\n","/**\n * Asynchronously maps over an array and flattens the result.\n * Similar to Array.prototype.flatMap but for async operations.\n * @param array - The input array to map over\n * @param callback - The async mapping function to apply to each element\n * @param defaultValue - The default value to return if the array is empty\n * @returns A flattened array of results\n * @example\n * // Basic usage with number arrays\n * const numbers = [1, 2, 3];\n * const result = await flatMapAsync(\n *   numbers,\n *   async (num) => [num, num * 2]\n * );\n * console.log(result); // [1, 2, 2, 4, 3, 6]\n * @example\n * // Error handling with default value\n * const data = ['valid', 'invalid'];\n * const result = await flatMapAsync(\n *   data,\n *   async (item) => {\n *     if (item === 'invalid') throw new Error();\n *     return [item.toUpperCase()];\n *   },\n *   ['DEFAULT']\n * );\n * console.log(result); // ['VALID', 'DEFAULT']\n */\nexport async function flatMapAsync<T, U>(\n  array: T[],\n  callback: (item: T) => Promise<U[]>,\n  defaultValue: U[] = [],\n): Promise<U[]> {\n  if (array.length === 0) {\n    return defaultValue;\n  }\n\n  const results = await Promise.all(\n    array.map(async (item) => {\n      try {\n        return await callback(item);\n      } catch (_error) {\n        return defaultValue;\n      }\n    }),\n  );\n  return results.flat();\n}\n","import { flatMapAsync } from \"@utils/flatMapAsync\";\nimport { createTaggedLogger } from \"@utils/logHelpers\";\n\nimport type {\n  BrowserName,\n  CookieQueryStrategy,\n  ExportedCookie,\n} from \"../../types/schemas\";\n\n/**\n * A composite strategy that combines multiple cookie query strategies.\n * This class implements the CookieQueryStrategy interface and allows querying cookies\n * from multiple browser-specific strategies simultaneously.\n * @example\n * ```typescript\n * const strategy = new CompositeCookieQueryStrategy([\n *   new ChromeCookieQueryStrategy(),\n *   new FirefoxCookieQueryStrategy(),\n *   new SafariCookieQueryStrategy()\n * ]);\n * const cookies = await strategy.queryCookies('sessionId', 'example.com');\n * ```\n */\nexport class CompositeCookieQueryStrategy implements CookieQueryStrategy {\n  private readonly logger = createTaggedLogger(\"CompositeCookieQueryStrategy\");\n\n  /**\n   * The browser name identifier for this strategy\n   * @remarks Always returns 'internal' as this is a composite strategy\n   */\n  public readonly browserName: BrowserName = \"internal\";\n\n  /**\n   * Creates a new instance of CompositeCookieQueryStrategy\n   * @param strategies - Array of browser-specific strategies to use for querying cookies\n   * @remarks\n   * - Each strategy in the array should implement the CookieQueryStrategy interface\n   * - The order of strategies determines the order of cookie querying\n   * - Failed strategies will be gracefully handled and skipped\n   * @example\n   * ```typescript\n   * const strategy = new CompositeCookieQueryStrategy([\n   *   new ChromeCookieQueryStrategy(),\n   *   new FirefoxCookieQueryStrategy()\n   * ]);\n   * ```\n   */\n  public constructor(private strategies: CookieQueryStrategy[]) {}\n\n  /**\n   * Handles strategy-specific errors and logs them appropriately\n   * @internal\n   * @param error - The error that occurred during strategy execution\n   * @param strategy - The strategy that failed\n   */\n  private handleStrategyError(\n    error: unknown,\n    strategy: CookieQueryStrategy,\n  ): void {\n    if (error instanceof Error) {\n      this.logger.error(\"Strategy failed\", { error, strategy });\n    } else {\n      this.logger.error(\"Strategy failed with unknown error\", {\n        error: String(error),\n        strategy,\n      });\n    }\n  }\n\n  /**\n   * Queries cookies using all available strategies in parallel\n   * @param name - The name pattern to match cookies against\n   * @param domain - The domain pattern to match cookies against\n   * @param store - The store pattern to match cookies against\n   * @returns Promise resolving to combined array of cookies from all strategies\n   * @remarks\n   * - Failures in individual strategies are logged but don't affect other strategies\n   * - Results are combined from all successful strategy queries\n   * - Empty arrays are returned for failed strategy queries\n   * @example\n   * ```typescript\n   * const strategy = new CompositeCookieQueryStrategy([\n   *   new ChromeCookieQueryStrategy(),\n   *   new FirefoxCookieQueryStrategy()\n   * ]);\n   * const cookies = await strategy.queryCookies('sessionId', 'example.com');\n   * console.log(cookies); // Combined results from all browsers\n   * ```\n   */\n  public async queryCookies(\n    name: string,\n    domain: string,\n    store?: string,\n  ): Promise<ExportedCookie[]> {\n    try {\n      this.logger.info(\"Querying cookies from all strategies\", {\n        name,\n        domain,\n        store,\n        strategyCount: this.strategies.length,\n      });\n\n      /**\n       * Use flatMapAsync to process strategies in sequence while collecting results\n       * This approach provides better error isolation than Promise.all\n       * Each strategy failure is handled independently\n       */\n      return await flatMapAsync(\n        this.strategies,\n        async (strategy) => {\n          try {\n            return await strategy.queryCookies(name, domain, store);\n          } catch (error) {\n            this.handleStrategyError(error, strategy);\n            return [];\n          }\n        },\n        [],\n      );\n    } catch (error) {\n      /**\n       * Handle top-level errors that may occur during strategy processing\n       * This ensures the function always returns an array, even in catastrophic failure\n       */\n      if (error instanceof Error) {\n        this.logger.error(\"Failed to query cookies\", { error });\n      } else {\n        this.logger.error(\"Failed to query cookies with unknown error\", {\n          error: String(error),\n        });\n      }\n      return [];\n    }\n  }\n}\n","import { homedir } from \"os\";\nimport { join } from \"path\";\n\nimport fg from \"fast-glob\";\n\nimport { createTaggedLogger, logWarn } from \"@utils/logHelpers\";\n\nconst logger = createTaggedLogger(\"FirefoxCookieQueryStrategy\");\n\nimport {\n  BrowserName,\n  CookieQueryStrategy,\n  ExportedCookie,\n} from \"../../../types/schemas\";\nimport { querySqliteThenTransform } from \"../QuerySqliteThenTransform\";\n\ninterface FirefoxCookieRow {\n  name: string;\n  value: string;\n  domain: string;\n  expiry: number;\n}\n\n/**\n * Find all Firefox cookie database files\n * @returns An array of file paths to Firefox cookie databases\n */\nfunction findFirefoxCookieFiles(): string[] {\n  const home = homedir();\n  if (!home) {\n    logWarn(\"FirefoxCookieQuery\", \"Failed to get home directory\");\n    return [];\n  }\n\n  const patterns = [\n    join(home, \"Library/Application Support/Firefox/Profiles/*/cookies.sqlite\"),\n    join(home, \".mozilla/firefox/*/cookies.sqlite\"),\n  ];\n\n  const files: string[] = [];\n  for (const pattern of patterns) {\n    const matches = fg.sync(pattern);\n    files.push(...matches);\n  }\n\n  logger.debug(\"Found Firefox cookie files\", { files });\n  return files;\n}\n\n/**\n * Strategy for querying cookies from Firefox browser\n * @example\n */\nexport class FirefoxCookieQueryStrategy implements CookieQueryStrategy {\n  /**\n   *\n   */\n  public readonly browserName: BrowserName = \"Firefox\";\n\n  /**\n   * Queries cookies from Firefox's cookie store\n   * @param name - The name pattern to match cookies against\n   * @param domain - The domain pattern to match cookies against\n   * @param store - Optional path to a specific cookie store file\n   * @returns A promise that resolves to an array of exported cookies\n   */\n  public async queryCookies(\n    name: string,\n    domain: string,\n    store?: string,\n  ): Promise<ExportedCookie[]> {\n    const files = store ?? findFirefoxCookieFiles();\n    const fileList = Array.isArray(files) ? files : [files];\n    const results: ExportedCookie[] = [];\n\n    for (const file of fileList) {\n      try {\n        const cookies = await querySqliteThenTransform<\n          FirefoxCookieRow,\n          ExportedCookie\n        >({\n          file,\n          sql: \"SELECT name, value, host as domain, expiry FROM moz_cookies WHERE name = ? AND host LIKE ?\",\n          params: [name, `%${domain}%`],\n          rowTransform: (row) => ({\n            name: row.name,\n            value: row.value,\n            domain: row.domain,\n            expiry: row.expiry > 0 ? new Date(row.expiry * 1000) : \"Infinity\",\n            meta: {\n              file,\n              browser: \"Firefox\",\n              decrypted: false,\n            },\n          }),\n        });\n\n        results.push(...cookies);\n      } catch (error) {\n        if (error instanceof Error) {\n          logWarn(\n            \"FirefoxCookieQuery\",\n            `Error reading Firefox cookie file ${file}`,\n            { error: error.message },\n          );\n        } else {\n          logWarn(\n            \"FirefoxCookieQuery\",\n            `Error reading Firefox cookie file ${file}`,\n          );\n        }\n      }\n    }\n\n    return results;\n  }\n}\n","import { homedir } from \"os\";\nimport { join } from \"path\";\n\nimport { logError } from \"@utils/logHelpers\";\n\nimport type {\n  BrowserName,\n  CookieQueryStrategy,\n  ExportedCookie,\n} from \"../../../types/schemas\";\n\nimport { decodeBinaryCookies } from \"./decodeBinaryCookies\";\n\n/**\n * Strategy for querying cookies from Safari browser\n */\nexport class SafariCookieQueryStrategy implements CookieQueryStrategy {\n  /**\n   * The browser name for this strategy\n   */\n  public readonly browserName: BrowserName = \"Safari\";\n\n  /**\n   * Gets the path to Safari's cookie database\n   * @param home - The user's home directory\n   * @returns Path to the cookie database\n   */\n  private getCookieDbPath(home: string): string {\n    return join(\n      home,\n      \"Library\",\n      \"Containers\",\n      \"com.apple.Safari\",\n      \"Data\",\n      \"Library\",\n      \"Cookies\",\n      \"Cookies.binarycookies\",\n    );\n  }\n\n  /**\n   * Formats the domain by removing leading dot if present\n   * @param domain - Domain to format\n   * @returns Formatted domain\n   */\n  private formatDomain(domain: string): string {\n    return domain.startsWith(\".\") ? domain.slice(1) : domain;\n  }\n\n  /**\n   * Formats the expiry date\n   * @param expiry - Expiry timestamp\n   * @returns Formatted expiry date\n   */\n  private formatExpiry(expiry: number): Date | \"Infinity\" {\n    if (expiry <= 0) {\n      return \"Infinity\";\n    }\n    return new Date(expiry * 1000);\n  }\n\n  /**\n   * Checks if a flag bit is set\n   * @param flags - The flags value\n   * @param bit - The bit to check\n   * @returns True if the bit is set, false otherwise\n   */\n  private isFlagSet(flags: number | undefined | null, bit: number): boolean {\n    if (typeof flags !== \"number\" || isNaN(flags) || flags <= 0) {\n      return false;\n    }\n    return (flags & bit) === bit;\n  }\n\n  /**\n   * Formats the creation timestamp\n   * @param creation - Creation timestamp\n   * @returns Formatted creation timestamp or undefined\n   */\n  private formatCreation(\n    creation: number | undefined | null,\n  ): number | undefined {\n    if (typeof creation !== \"number\" || isNaN(creation) || creation <= 0) {\n      return undefined;\n    }\n    return creation * 1000;\n  }\n\n  /**\n   * Decodes cookies from Safari's binary cookie file\n   * @param cookieDbPath - Path to the cookie database\n   * @param name - Name of the cookie to find\n   * @param domain - Domain to filter cookies by\n   * @returns Array of exported cookies\n   */\n  private decodeCookies(\n    cookieDbPath: string,\n    name: string,\n    domain: string,\n  ): ExportedCookie[] {\n    try {\n      const cookies = decodeBinaryCookies(cookieDbPath);\n      return cookies\n        .filter(\n          (cookie) =>\n            (name === \"%\" || cookie.name === name) &&\n            (domain === \"%\" ||\n              this.formatDomain(cookie.domain).includes(domain)),\n        )\n        .map((cookie) => ({\n          domain: this.formatDomain(cookie.domain),\n          name: cookie.name,\n          value: Buffer.isBuffer(cookie.value)\n            ? cookie.value.toString()\n            : String(cookie.value),\n          expiry: this.formatExpiry(cookie.expiry),\n          meta: {\n            file: cookieDbPath,\n            browser: \"Safari\" as const,\n            decrypted: false,\n            secure: this.isFlagSet(cookie.flags, 0x1),\n            httpOnly: this.isFlagSet(cookie.flags, 0x4),\n            path: cookie.path,\n            version: cookie.version,\n            comment: cookie.comment,\n            commentURL: cookie.commentURL,\n            port: cookie.port,\n            creation: this.formatCreation(cookie.creation),\n          },\n        }));\n    } catch (error) {\n      if (error instanceof Error) {\n        logError(\n          \"SafariCookieQueryStrategy\",\n          `Error decoding ${cookieDbPath}`,\n          { error, name, domain },\n        );\n      } else {\n        logError(\n          \"SafariCookieQueryStrategy\",\n          `Error decoding ${cookieDbPath}`,\n          { error: \"Unknown error\", name, domain },\n        );\n      }\n      return [];\n    }\n  }\n\n  /**\n   * Query Safari's cookie storage for cookies matching the given criteria\n   * @param name - Name of the cookie to find\n   * @param domain - Domain to filter cookies by\n   * @param store - Optional store path\n   * @returns Array of matching cookies, or empty array if none found\n   */\n  public async queryCookies(\n    name: string,\n    domain: string,\n    store?: string,\n  ): Promise<ExportedCookie[]> {\n    const home = homedir();\n    if (typeof home !== \"string\" || home.length === 0) {\n      logError(\"SafariCookieQueryStrategy\", \"Failed to get home directory\");\n      return Promise.resolve([]);\n    }\n\n    const cookieDbPath = store ?? this.getCookieDbPath(home);\n    return Promise.resolve(\n      this.decodeCookies(cookieDbPath, name || \"%\", domain || \"%\"),\n    );\n  }\n}\n","import { Buffer } from \"buffer\";\nimport { readFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { join } from \"path\";\n\nimport { BinaryCookieRow } from \"../../../types/schemas\";\nimport { logWarn, createTaggedLogger } from \"../../../utils/logHelpers\";\n\nimport { BinaryCodablePage } from \"./BinaryCodablePage\";\nimport { BinaryCodableContainer } from \"./interfaces/BinaryCodableContainer\";\n\nconst logger = createTaggedLogger(\"BinaryCodableCookies\");\n\n/**\n * Represents a binary cookies file structure used by Safari\n */\nexport class BinaryCodableCookies {\n  /**\n   *\n   */\n  public pages: BinaryCodablePage[];\n  /**\n   *\n   */\n  public metadata: Record<string, unknown>;\n  private static readonly MAGIC = Buffer.from(\"cook\", \"utf8\");\n  private static readonly FOOTER = BigInt(\"0x071720050000004b\");\n  private static readonly DEFAULT_COOKIE_PATH = join(\n    homedir(),\n    \"Library/Containers/com.apple.Safari/Data/Library/Cookies/Cookies.binarycookies\",\n  );\n\n  /**\n   * Creates a new BinaryCookies instance from a buffer\n   * @param buffer - The raw binary cookie file data\n   */\n  public constructor(buffer: Buffer) {\n    const container: BinaryCodableContainer = { offset: 0, buffer };\n    this.pages = [];\n    this.metadata = {};\n    this.decode(container);\n  }\n\n  /**\n   * Creates a BinaryCookies instance from a file path\n   * @param path - Path to the Safari Cookies.binarycookies file\n   * @returns A new BinaryCookies instance\n   */\n  public static fromFile(path: string): BinaryCodableCookies {\n    const buffer = readFileSync(path);\n    return new BinaryCodableCookies(buffer);\n  }\n\n  /**\n   * Creates a BinaryCookies instance from the default Safari cookies location\n   * @returns A new BinaryCookies instance\n   */\n  public static fromDefaultPath(): BinaryCodableCookies {\n    return BinaryCodableCookies.fromFile(\n      BinaryCodableCookies.DEFAULT_COOKIE_PATH,\n    );\n  }\n\n  /**\n   * Converts the binary cookie data into a validated array of cookie rows\n   * @returns Array of validated cookie objects\n   */\n  public toCookieRows(): BinaryCookieRow[] {\n    const cookies: BinaryCookieRow[] = [];\n\n    for (const page of this.pages) {\n      try {\n        const pageCookies = page.toCookieRows();\n        if (Array.isArray(pageCookies)) {\n          cookies.push(...pageCookies);\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : String(error);\n        logWarn(\"BinaryCookies\", \"Error converting page cookies\", {\n          error: errorMessage,\n        });\n      }\n    }\n\n    return cookies;\n  }\n\n  private decode(container: BinaryCodableContainer): void {\n    try {\n      // Check magic value\n      const magic = container.buffer.subarray(\n        container.offset,\n        container.offset + 4,\n      );\n      container.offset += 4;\n      logger.debug(\"Magic bytes:\", magic.toString());\n      if (!magic.equals(BinaryCodableCookies.MAGIC)) {\n        throw new Error(\"Missing magic value\");\n      }\n\n      // Read page count\n      const pageCount = container.buffer.readUInt32BE(container.offset);\n      logger.debug(\"Page count:\", pageCount);\n      container.offset += 4;\n\n      // Read page sizes\n      const pageSizes: number[] = [];\n      for (let i = 0; i < pageCount; i++) {\n        const pageSize = container.buffer.readUInt32BE(container.offset);\n        pageSizes.push(pageSize);\n        logger.debug(`Page ${i} size:`, pageSize);\n        container.offset += 4;\n      }\n\n      // Calculate page offsets\n      let currentOffset = container.offset;\n      logger.debug(\"Starting page data at offset:\", currentOffset);\n      for (const pageSize of pageSizes) {\n        try {\n          logger.debug(\n            \"Reading page at offset:\",\n            currentOffset,\n            \"with size:\",\n            pageSize,\n          );\n          const pageBuffer = container.buffer.subarray(\n            currentOffset,\n            currentOffset + pageSize,\n          );\n          const page = new BinaryCodablePage(pageBuffer);\n          this.pages.push(page);\n          currentOffset += pageSize;\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : String(error);\n          logger.warn(\"Error decoding page:\", { error: errorMessage });\n          currentOffset += pageSize; // Skip the problematic page\n        }\n      }\n      container.offset = currentOffset;\n\n      // Read checksum\n      const checksum = container.buffer.readUInt32BE(container.offset);\n      logger.debug(\"Checksum:\", checksum.toString(16));\n      container.offset += 4;\n\n      // Read footer\n      const footer = container.buffer.readBigUInt64BE(container.offset);\n      logger.debug(\"Footer:\", footer.toString(16));\n      container.offset += 8;\n      if (footer !== BinaryCodableCookies.FOOTER) {\n        logWarn(\"BinaryCookies\", \"Invalid cookie file format: wrong footer\");\n      }\n\n      // Read metadata plist\n      const _plistData = container.buffer.subarray(container.offset);\n      // Note: You'll need to implement or use a plist parser library here\n      this.metadata = {}; // Placeholder for plist data\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      logWarn(\"BinaryCookies\", \"Error decoding binary cookies file\", {\n        error: errorMessage,\n      });\n      throw error;\n    }\n  }\n}\n","import { Buffer } from \"buffer\";\n\nimport { BinaryCookieRow, BinaryCookieRowSchema } from \"../../../types/schemas\";\nimport { createTaggedLogger } from \"../../../utils/logHelpers\";\n\nimport { BinaryCodableContainer } from \"./interfaces/BinaryCodableContainer\";\nimport { BinaryCodableFlags } from \"./interfaces/BinaryCodableFlags\";\nimport { BinaryCodableOffsets } from \"./interfaces/BinaryCodableOffsets\";\n\nconst logger = createTaggedLogger(\"BinaryCodableCookie\");\n\n/**\n * Represents a single cookie within a page\n */\nexport class BinaryCodableCookie {\n  /**\n   *\n   */\n  public version = 0;\n  /**\n   *\n   */\n  public url = \"\";\n  /**\n   *\n   */\n  public port?: number;\n  /**\n   *\n   */\n  public name = \"\";\n  /**\n   *\n   */\n  public path = \"\";\n  /**\n   *\n   */\n  public value = \"\";\n  /**\n   *\n   */\n  public comment?: string;\n  /**\n   *\n   */\n  public commentURL?: string;\n  /**\n   *\n   */\n  public flags: BinaryCodableFlags = {\n    isSecure: false,\n    isHTTPOnly: false,\n    unknown1: false,\n    unknown2: false,\n  };\n  /**\n   *\n   */\n  public expiration = 0;\n  /**\n   *\n   */\n  public creation = 0;\n\n  /**\n   * Creates a new Cookie instance from a buffer\n   * @param buffer - The raw binary cookie data\n   */\n  public constructor(buffer: Buffer) {\n    const container: BinaryCodableContainer = { offset: 0, buffer };\n    this.decode(container);\n  }\n\n  private decodeUrlValue(value: string): string {\n    let processed = value;\n    let lastProcessed;\n    do {\n      lastProcessed = processed;\n      try {\n        processed = decodeURIComponent(processed);\n      } catch {\n        return lastProcessed;\n      }\n    } while (processed !== lastProcessed && processed.includes(\"%\"));\n    return processed;\n  }\n\n  private decodeJwtPayload(token: string): string | null {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    try {\n      const payload = Buffer.from(parts[1], \"base64\").toString(\"utf8\");\n      const parsed = JSON.parse(payload) as Record<string, unknown>;\n      return JSON.stringify(parsed);\n    } catch {\n      return null;\n    }\n  }\n\n  private parseJsonValue(value: string): string | null {\n    try {\n      const parsed = JSON.parse(value) as Record<string, unknown>;\n      return JSON.stringify(parsed);\n    } catch {\n      return null;\n    }\n  }\n\n  private processValue(value: string): string {\n    // First, try URL decoding\n    const decoded = this.decodeUrlValue(value);\n\n    // Then, try JWT decoding if it looks like a JWT token\n    if (decoded.match(/^ey[A-Za-z0-9_-]+\\.ey[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+$/)) {\n      const jwtPayload = this.decodeJwtPayload(decoded);\n      if (typeof jwtPayload === \"string\" && jwtPayload.length > 0) {\n        return jwtPayload;\n      }\n    }\n\n    // Finally, try JSON parsing if it looks like JSON\n    if (decoded.startsWith(\"{\") || decoded.startsWith(\"[\")) {\n      const jsonValue = this.parseJsonValue(decoded);\n      if (typeof jsonValue === \"string\" && jsonValue.length > 0) {\n        return jsonValue;\n      }\n    }\n\n    return decoded;\n  }\n\n  /**\n   * Converts the cookie to a validated cookie row\n   * @returns Validated cookie row object or null if validation fails\n   */\n  public toCookieRow(): BinaryCookieRow | null {\n    try {\n      // Convert flags to number\n      const flagsValue = this.convertFlags();\n\n      // Extract domain from URL\n      const domain =\n        this.url.replace(/^https?:\\/\\//, \"\").replace(/\\/.*$/, \"\") || \"uk\";\n\n      // Convert timestamps from Mac epoch (seconds since 2001-01-01) to Unix epoch (seconds since 1970-01-01)\n      const macToUnixOffset = 978307200; // Seconds between 1970-01-01 and 2001-01-01\n      const expiryUnix =\n        this.expiration > 0\n          ? this.expiration + macToUnixOffset\n          : this.expiration;\n      const creationUnix =\n        this.creation > 0 ? this.creation + macToUnixOffset : this.creation;\n\n      // Create cookie row with converted timestamps\n      const cookieRow = BinaryCookieRowSchema.parse({\n        name: this.name.replace(/^: /, \"\"), // Remove leading ': ' if present\n        value: this.processValue(this.value) || \"\", // Process and ensure value is never undefined\n        domain,\n        path: this.path || \"/\",\n        expiry: expiryUnix,\n        creation: creationUnix,\n        flags: flagsValue,\n        version: this.version,\n        port: this.port,\n        comment: this.comment,\n        commentURL: this.commentURL,\n      });\n\n      return cookieRow;\n    } catch (_error) {\n      return null;\n    }\n  }\n\n  private readNullTerminatedString(\n    container: BinaryCodableContainer,\n    offset: number,\n  ): string {\n    let end = offset;\n    while (end < container.buffer.length && container.buffer[end] !== 0) {\n      end++;\n    }\n    const value = container.buffer.toString(\"utf8\", offset, end);\n    return value || \"\";\n  }\n\n  private readHeader(container: BinaryCodableContainer): {\n    size: number;\n    hasPort: number;\n    offsets: BinaryCodableOffsets;\n  } {\n    // Cookie size (4 bytes)\n    const size = container.buffer.readUInt32LE(container.offset);\n    logger.debug(\"Cookie size:\", size);\n    container.offset += 4;\n\n    // Version (4 bytes)\n    const version = container.buffer.readUInt32LE(container.offset);\n    logger.debug(\"Cookie version:\", version);\n    container.offset += 4;\n\n    // Cookie flags (4 bytes)\n    const flagsValue = container.buffer.readUInt32LE(container.offset);\n    logger.debug(\"Cookie flags:\", flagsValue.toString(2).padStart(8, \"0\"));\n    container.offset += 4;\n    this.flags = {\n      isSecure: (flagsValue & 1) !== 0,\n      isHTTPOnly: (flagsValue & 4) !== 0,\n      unknown1: (flagsValue & 8) !== 0,\n      unknown2: (flagsValue & 16) !== 0,\n    };\n\n    // Has port (4 bytes)\n    const hasPort = container.buffer.readUInt32LE(container.offset);\n    logger.debug(\"Has port:\", hasPort);\n    container.offset += 4;\n\n    // String offsets (24 bytes total)\n    const offsets = {\n      urlOffset: container.buffer.readUInt32LE(container.offset),\n      nameOffset: container.buffer.readUInt32LE(container.offset + 4),\n      pathOffset: container.buffer.readUInt32LE(container.offset + 8),\n      valueOffset: container.buffer.readUInt32LE(container.offset + 12),\n      commentOffset: container.buffer.readUInt32LE(container.offset + 16),\n      commentURLOffset: container.buffer.readUInt32LE(container.offset + 20),\n    };\n    logger.debug(\"String offsets:\", offsets);\n\n    return { size, hasPort, offsets };\n  }\n\n  private readTimestamps(container: BinaryCodableContainer): void {\n    // Read expiration time (8 bytes, little-endian double)\n    const expirationBuffer = Buffer.alloc(8);\n    for (let i = 0; i < 8; i++) {\n      expirationBuffer[i] = container.buffer[container.offset + i];\n    }\n    const expiration = expirationBuffer.readDoubleLE(0);\n    container.offset += 8;\n\n    // Read creation time (8 bytes, little-endian double)\n    const creationBuffer = Buffer.alloc(8);\n    for (let i = 0; i < 8; i++) {\n      creationBuffer[i] = container.buffer[container.offset + i];\n    }\n    const creation = creationBuffer.readDoubleLE(0);\n    container.offset += 8;\n\n    // Store raw timestamps (seconds since 2001-01-01)\n    // For expiration time, 0 means \"session cookie\" (expires when browser closes)\n    // For creation time, 0 means \"no creation time recorded\"\n    this.expiration = expiration;\n    this.creation = creation;\n  }\n\n  private readStrings(\n    container: BinaryCodableContainer,\n    size: number,\n    offsets: BinaryCodableOffsets,\n  ): void {\n    // All offsets are relative to the start of the cookie\n    const cookieStart = 0; // Offsets are relative to the cookie buffer start\n    logger.debug(\"Reading strings from cookie buffer of size:\", size);\n\n    // Read strings in order of their offsets\n    const offsetEntries = [\n      { field: \"url\", offset: offsets.urlOffset },\n      { field: \"name\", offset: offsets.nameOffset },\n      { field: \"path\", offset: offsets.pathOffset },\n      { field: \"value\", offset: offsets.valueOffset },\n      { field: \"comment\", offset: offsets.commentOffset },\n    ]\n      .filter((entry) => entry.offset > 0)\n      .sort((a, b) => a.offset - b.offset);\n\n    logger.debug(\n      \"Reading strings in order:\",\n      offsetEntries.map((e) => e.field),\n    );\n\n    // Calculate string lengths based on offset differences\n    for (let i = 0; i < offsetEntries.length; i++) {\n      const { field, offset } = offsetEntries[i];\n      const nextOffset =\n        i < offsetEntries.length - 1 ? offsetEntries[i + 1].offset : size;\n      const length = nextOffset - offset;\n\n      // Read string up to null terminator\n      let end = cookieStart + offset;\n      while (\n        end < cookieStart + offset + length &&\n        container.buffer[end] !== 0\n      ) {\n        end++;\n      }\n      const value = container.buffer.toString(\n        \"utf8\",\n        cookieStart + offset,\n        end,\n      );\n      logger.debug(`Read ${field}:`, value);\n\n      switch (field) {\n        case \"url\":\n          this.url = value;\n          break;\n        case \"name\":\n          this.name = value;\n          break;\n        case \"path\":\n          this.path = value;\n          break;\n        case \"value\":\n          this.value = value;\n          break;\n        case \"comment\":\n          this.comment = value;\n          break;\n      }\n    }\n  }\n\n  private decode(container: BinaryCodableContainer): void {\n    const { size, hasPort, offsets } = this.readHeader(container);\n\n    // Skip past all offsets (24 bytes)\n    const baseOffset = container.offset;\n    container.offset = baseOffset + 24;\n\n    this.readTimestamps(container);\n\n    if (hasPort > 0) {\n      this.port = container.buffer.readUInt16LE(container.offset);\n      container.offset += 2;\n    }\n\n    // Reset offset for string reading\n    container.offset = baseOffset;\n    this.readStrings(container, size, offsets);\n  }\n\n  private convertFlags(): number {\n    return (\n      (this.flags.isSecure ? 0x1 : 0) |\n      (this.flags.isHTTPOnly ? 0x4 : 0) |\n      (this.flags.unknown1 ? 0x8 : 0) |\n      (this.flags.unknown2 ? 0x10 : 0)\n    );\n  }\n}\n","import destr from \"destr\";\nimport { z } from \"zod\";\n\n/**\n * Zod schema for cookie domain validation.\n * Enforces standard cookie domain rules.\n * @example\n * ```typescript\n * // Valid domains\n * CookieDomainSchema.parse(\"example.com\");     // OK\n * CookieDomainSchema.parse(\".example.com\");    // OK - leading dot is valid\n * CookieDomainSchema.parse(\"sub.example.com\"); // OK\n *\n * // Invalid domains\n * CookieDomainSchema.parse(\"\");               // Error: Domain cannot be empty\n * CookieDomainSchema.parse(\"invalid domain\"); // Error: Invalid domain format\n * ```\n */\nexport const CookieDomainSchema = z\n  .string()\n  .trim()\n  .min(1, \"Domain cannot be empty\")\n  .refine(\n    (domain) =>\n      /^\\.?[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(\n        domain,\n      ),\n    \"Invalid domain format\",\n  );\n\n/**\n * Zod schema for cookie name validation.\n * Enforces standard cookie name rules according to RFC 6265.\n * @example\n * ```typescript\n * // Valid names\n * CookieNameSchema.parse(\"session\");          // OK\n * CookieNameSchema.parse(\"auth_token\");       // OK\n * CookieNameSchema.parse(\"user-preference\");  // OK\n *\n * // Invalid names\n * CookieNameSchema.parse(\"\");                 // Error: Cookie name cannot be empty\n * CookieNameSchema.parse(\"session;\");         // Error: Invalid cookie name format\n * CookieNameSchema.parse(\"my cookie\");        // Error: Invalid cookie name format\n * ```\n */\nexport const CookieNameSchema = z\n  .string()\n  .trim()\n  .min(1, \"Cookie name cannot be empty\")\n  .refine(\n    (name) => name === \"%\" || /^[!#$%&'()*+\\-.:0-9A-Z \\^_`a-z|~]+$/.test(name),\n    \"Invalid cookie name format - must contain only valid characters (letters, numbers, and certain symbols) or be '%' for wildcard\",\n  );\n\n/**\n * Zod schema for cookie path validation.\n * Enforces standard cookie path rules according to RFC 6265.\n * @example\n * ```typescript\n * // Valid paths\n * CookiePathSchema.parse(\"/\");              // OK\n * CookiePathSchema.parse(\"/api\");           // OK\n * CookiePathSchema.parse(\"/path/to/page\");  // OK\n *\n * // Invalid paths\n * CookiePathSchema.parse(\"\");               // Error: Path cannot be empty\n * CookiePathSchema.parse(\"invalid\");        // Error: Path must start with /\n * CookiePathSchema.parse(\"/path?query\");    // Error: Invalid path format\n * ```\n */\nexport const CookiePathSchema = z\n  .string()\n  .trim()\n  .min(1, \"Path cannot be empty\")\n  .refine((path) => path.startsWith(\"/\"), \"Path must start with /\")\n  .refine(\n    (path) => /^\\/[!#$%&'()*+,\\-./:=@\\w~]*$/.test(path),\n    \"Invalid path format - must contain only valid URL path characters\",\n  )\n  .default(\"/\");\n\n/**\n * Zod schema for cookie value.\n * Attempts to parse JSON values using destr for better readability.\n */\nexport const CookieValueSchema = z\n  .string()\n  .trim()\n  .transform((value) => destr(value))\n  .pipe(z.any());\n\n/**\n * Zod schema for Safari binary cookie row.\n * Validates and enforces the structure of cookie data read from Safari's Cookies.binarycookies file.\n * @example\n * ```typescript\n * const cookieData = {\n *   name: \"session\",\n *   value: \"abc123\",\n *   domain: \"example.com\",\n *   path: \"/\",\n *   expiry: 1735689600,\n *   creation: 1672531200,\n *   flags: 0x5, // Secure + HTTPOnly\n * };\n * const validCookie = BinaryCookieRowSchema.parse(cookieData);\n * ```\n */\nexport const BinaryCookieRowSchema = z.object({\n  name: CookieNameSchema,\n  value: CookieValueSchema,\n  domain: CookieDomainSchema,\n  path: CookiePathSchema,\n  expiry: z.number().int(),\n  creation: z.number().int(),\n  flags: z.number().optional(),\n  version: z.number().int().optional(),\n  port: z.number().int().optional(),\n  comment: z.string().optional(),\n  commentURL: z.string().optional(),\n});\n\n/**\n * Type representing a decoded Safari binary cookie.\n * This type is inferred from the BinaryCookieRowSchema and includes all cookie properties.\n * @property name - The name of the cookie (non-empty string)\n * @property value - The value stored in the cookie\n * @property domain - The domain the cookie belongs to (non-empty string)\n * @property path - The path where the cookie is valid (defaults to \"/\")\n * @property expiry - Unix timestamp when the cookie expires\n * @property creation - Unix timestamp when the cookie was created\n * @property flags - Optional bit flags (e.g., Secure, HTTPOnly)\n * @property version - Optional cookie version number\n * @property port - Optional port number restriction\n * @property comment - Optional cookie comment\n * @property commentURL - Optional URL for the cookie's comment\n */\nexport type BinaryCookieRow = z.infer<typeof BinaryCookieRowSchema>;\n\n/**\n * Schema for cookie specification parameters\n * Defines the required fields for identifying a cookie\n * @example\n * ```typescript\n * // Validate a cookie specification\n * const spec = {\n *   name: 'session',\n *   domain: 'example.com'\n * };\n * const result = CookieSpecSchema.safeParse(spec);\n * if (result.success) {\n *   logger.info('Valid cookie spec:', result.data);\n * } else {\n *   logger.error('Invalid cookie spec:', result.error);\n * }\n *\n * // Invalid spec (empty name)\n * const invalidSpec = {\n *   name: '',\n *   domain: 'example.com'\n * };\n * // Throws: \"Cookie name cannot be empty\"\n * CookieSpecSchema.parse(invalidSpec);\n * ```\n */\nexport const CookieSpecSchema = z\n  .object({\n    name: CookieNameSchema,\n    domain: CookieDomainSchema,\n  })\n  .strict();\n\n/**\n * Type definition for cookie specification\n * Used for specifying which cookie to query\n * @example\n * ```typescript\n * // Basic cookie spec\n * const spec: CookieSpec = {\n *   name: 'auth',\n *   domain: 'api.example.com'\n * };\n *\n * // Use in function parameters\n * function queryCookie(spec: CookieSpec): Promise<ExportedCookie[]> {\n *   return getCookie(spec);\n * }\n *\n * // Array of specs\n * const specs: CookieSpec[] = [\n *   { name: 'session', domain: 'app.example.com' },\n *   { name: 'theme', domain: 'example.com' }\n * ];\n * ```\n */\nexport type CookieSpec = z.infer<typeof CookieSpecSchema>;\n\n/**\n * Schema for metadata about a cookie\n */\nexport const CookieMetaSchema = z\n  .object({\n    file: z.string().trim().min(1, \"File path cannot be empty\").optional(),\n    browser: z.string().trim().optional(),\n    decrypted: z.boolean().optional(),\n    secure: z.boolean().optional(),\n    httpOnly: z.boolean().optional(),\n    path: CookiePathSchema.optional(),\n  })\n  .catchall(z.unknown())\n  .strict();\n\n/**\n * Type definition for cookie metadata\n */\nexport type CookieMeta = z.infer<typeof CookieMetaSchema>;\n\n/**\n * Schema for exported cookie data\n * Represents a cookie with all its properties and metadata\n * @example\n * ```typescript\n * // Validate an exported cookie\n * const cookie = {\n *   domain: 'example.com',\n *   name: 'session',\n *   value: 'abc123',\n *   expiry: new Date('2024-12-31'),\n *   meta: {\n *     file: '/path/to/cookies.db'\n *   }\n * };\n * const result = ExportedCookieSchema.safeParse(cookie);\n * if (result.success) {\n *   logger.info('Valid cookie:', result.data);\n * } else {\n *   logger.error('Invalid cookie:', result.error);\n * }\n *\n * // Cookie with infinite expiry\n * const infiniteCookie = {\n *   ...cookie,\n *   expiry: \"Infinity\"\n * };\n * ExportedCookieSchema.parse(infiniteCookie); // OK\n * ```\n */\nexport const ExportedCookieSchema = z\n  .object({\n    domain: CookieDomainSchema,\n    name: CookieNameSchema,\n    value: CookieValueSchema,\n    expiry: z\n      .union([\n        z.literal(\"Infinity\"),\n        z.date(),\n        z.number().int().positive(\"Expiry must be a positive number\"),\n      ])\n      .optional(),\n    meta: CookieMetaSchema.optional(),\n  })\n  .strict();\n\n/**\n * Type definition for exported cookie data\n * Represents the structure of a cookie after it has been retrieved\n * @example\n * ```typescript\n * // Basic exported cookie\n * const cookie: ExportedCookie = {\n *   domain: 'example.com',\n *   name: 'session',\n *   value: 'abc123',\n *   expiry: new Date('2024-12-31'),\n *   meta: {\n *     file: '/path/to/cookies.db'\n *   }\n * };\n *\n * // Process exported cookies\n * function processCookies(cookies: ExportedCookie[]): string[] {\n *   return cookies.map(cookie => `${cookie.name}=${cookie.value}`);\n * }\n *\n * // Filter expired cookies\n * function filterExpired(cookies: ExportedCookie[]): ExportedCookie[] {\n *   const now = new Date();\n *   return cookies.filter(cookie =>\n *     cookie.expiry === \"Infinity\" ||\n *     (cookie.expiry instanceof Date && cookie.expiry > now)\n *   );\n * }\n * ```\n */\nexport type ExportedCookie = z.infer<typeof ExportedCookieSchema>;\n\n/**\n * Schema for raw cookie data from browser stores\n */\nexport const CookieRowSchema = z\n  .object({\n    expiry: z.number().int().optional(),\n    domain: CookieDomainSchema,\n    name: CookieNameSchema,\n    value: z.union([z.string(), z.instanceof(Buffer)]),\n  })\n  .strict();\n\n/**\n * Type definition for raw cookie data\n */\nexport type CookieRow = z.infer<typeof CookieRowSchema>;\n\n/**\n * Schema for cookie render options\n */\nexport const RenderOptionsSchema = z\n  .object({\n    format: z.enum([\"merged\", \"grouped\"]).optional(),\n    separator: z.string().optional(),\n    showFilePaths: z.boolean().optional(),\n  })\n  .strict();\n\n/**\n * Type definition for render options\n */\nexport type RenderOptions = z.infer<typeof RenderOptionsSchema>;\n\n/**\n * Schema for browser names\n */\nexport const BrowserNameSchema = z.enum([\n  \"Chrome\",\n  \"Firefox\",\n  \"Safari\",\n  \"internal\",\n  \"unknown\",\n]);\n\n/**\n * Type definition for browser names\n */\nexport type BrowserName = z.infer<typeof BrowserNameSchema>;\n\n/**\n * Schema for cookie query strategy\n */\nexport const CookieQueryStrategySchema = z\n  .object({\n    browserName: BrowserNameSchema,\n    queryCookies: z\n      .function()\n      .args(z.string(), z.string(), z.string().optional())\n      .returns(z.promise(z.array(ExportedCookieSchema))),\n  })\n  .strict();\n\n/**\n * Type definition for cookie query strategy\n */\nexport type CookieQueryStrategy = z.infer<typeof CookieQueryStrategySchema>;\n\n/**\n * Type representing either a single cookie specification or an array of specifications.\n * Useful when you need to query multiple cookies in a single operation.\n * @example\n * ```typescript\n * // Single cookie spec\n * const single: MultiCookieSpec = {\n *   domain: \"example.com\",\n *   name: \"sessionId\"\n * };\n *\n * // Multiple cookie specs\n * const multiple: MultiCookieSpec = [\n *   { domain: \"example.com\", name: \"sessionId\" },\n *   { domain: \"api.example.com\", name: \"authToken\" }\n * ];\n * ```\n */\nexport type MultiCookieSpec = CookieSpec | CookieSpec[];\n\n/**\n *\n */\nexport interface CookieQueryOptions<\n  T extends CookieQueryStrategy = CookieQueryStrategy,\n> {\n  strategy: T;\n  limit?: number;\n  removeExpired?: boolean;\n  store?: string;\n}\n","import { Buffer } from \"buffer\";\n\nimport { BinaryCookieRow } from \"../../../types/schemas\";\nimport { logWarn } from \"../../../utils/logHelpers\";\nimport { createTaggedLogger } from \"../../../utils/logHelpers\";\n\nimport { BinaryCodableCookie } from \"./BinaryCodableCookie\";\nimport { BinaryCodableContainer } from \"./interfaces/BinaryCodableContainer\";\n\nconst logger = createTaggedLogger(\"BinaryCodablePage\");\n\n/**\n * Represents a page of cookies within the binary cookies file\n */\nexport class BinaryCodablePage {\n  /**\n   *\n   */\n  public cookies: BinaryCodableCookie[];\n  private static readonly HEADER = 0x00000100;\n  private static readonly FOOTER = 0x00000000;\n\n  /**\n   * Creates a new Page instance from a buffer\n   * @param buffer - The raw binary page data\n   */\n  public constructor(buffer: Buffer) {\n    this.cookies = [];\n    const container: BinaryCodableContainer = { offset: 0, buffer };\n    this.decode(container);\n  }\n\n  /**\n   * Converts the page's cookies into validated cookie rows\n   * @returns Array of validated cookie objects\n   */\n  public toCookieRows(): BinaryCookieRow[] {\n    const cookies: BinaryCookieRow[] = [];\n\n    for (const cookie of this.cookies) {\n      try {\n        const cookieRow = cookie.toCookieRow();\n        if (cookieRow !== null) {\n          cookies.push(cookieRow);\n        }\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : String(error);\n        logWarn(\"BinaryCookies\", \"Error converting cookie\", {\n          error: errorMessage,\n        });\n      }\n    }\n\n    return cookies;\n  }\n\n  private decode(container: BinaryCodableContainer): void {\n    // Read page tag (4 bytes)\n    const header = container.buffer.readUInt32BE(container.offset);\n    logger.debug(\"Page header:\", header.toString(16));\n    container.offset += 4;\n    if (header !== BinaryCodablePage.HEADER) {\n      throw new Error(\"Invalid page header\");\n    }\n\n    // Read number of cookies (4 bytes)\n    const cookieCount = container.buffer.readUInt32LE(container.offset);\n    logger.debug(\"Cookie count:\", cookieCount);\n    container.offset += 4;\n\n    // Store the page start offset for calculating absolute cookie positions\n    const pageStart = container.offset - 8;\n    logger.debug(\"Page start offset:\", pageStart);\n\n    // Read cookie offsets (4 bytes each)\n    const cookieOffsets: number[] = [];\n    for (let i = 0; i < cookieCount; i++) {\n      const cookieOffset = container.buffer.readUInt32LE(container.offset);\n      cookieOffsets.push(cookieOffset);\n      logger.debug(`Cookie ${i} offset:`, cookieOffset);\n      container.offset += 4;\n    }\n\n    // Read page end marker (4 bytes)\n    const footer = container.buffer.readUInt32BE(container.offset);\n    logger.debug(\"Page footer:\", footer.toString(16));\n    container.offset += 4;\n    if (footer !== BinaryCodablePage.FOOTER) {\n      throw new Error(\"Invalid page footer\");\n    }\n\n    // Read cookies at their offsets\n    for (let i = 0; i < cookieCount; i++) {\n      try {\n        const cookieOffset = cookieOffsets[i];\n        logger.debug(`Reading cookie ${i} at offset:`, cookieOffset);\n\n        // Read cookie size from the cookie header\n        const cookieSize = container.buffer.readUInt32LE(cookieOffset);\n        logger.debug(`Cookie ${i} size:`, cookieSize);\n        if (cookieSize < 48) {\n          // Minimum cookie size is 48 bytes (header)\n          logger.warn(`Invalid cookie size ${cookieSize} at index ${i}`);\n          continue;\n        }\n\n        // Ensure we don't read past the buffer\n        if (cookieOffset + cookieSize > container.buffer.length) {\n          logger.warn(\n            `Cookie size ${cookieSize} at index ${i} would exceed buffer length ${container.buffer.length}`,\n          );\n          continue;\n        }\n\n        const cookieBuffer = container.buffer.subarray(\n          cookieOffset,\n          cookieOffset + cookieSize,\n        );\n        const cookie = new BinaryCodableCookie(cookieBuffer);\n        this.cookies.push(cookie);\n      } catch (error) {\n        logger.warn(\"Invalid cookie data\", {\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n  }\n}\n","import type { BinaryCookieRow } from \"../../../types/schemas\";\n\nimport { BinaryCodableCookies } from \"./BinaryCodableCookies\";\n\n/**\n * Decodes a Safari binary cookie file into an array of cookie objects.\n * @param cookieDbPath - Path to the Safari Cookies.binarycookies file\n * @returns Array of decoded cookie objects\n * @throws {Error} If the file cannot be read or has invalid format\n */\nexport function decodeBinaryCookies(cookieDbPath: string): BinaryCookieRow[] {\n  const cookies = BinaryCodableCookies.fromFile(cookieDbPath);\n  return cookies.toCookieRows();\n}\n\n/**\n * Retrieves cookies from Safari's binary cookie store.\n * @returns Array of decoded Safari cookies\n */\nexport function getSafariCookies(): BinaryCookieRow[] {\n  const cookies = BinaryCodableCookies.fromDefaultPath();\n  return cookies.toCookieRows();\n}\n","import { ChromeCookieQueryStrategy } from \"@core/browsers/chrome/ChromeCookieQueryStrategy\";\nimport { CompositeCookieQueryStrategy } from \"@core/browsers/CompositeCookieQueryStrategy\";\nimport { FirefoxCookieQueryStrategy } from \"@core/browsers/firefox/FirefoxCookieQueryStrategy\";\nimport { SafariCookieQueryStrategy } from \"@core/browsers/safari/SafariCookieQueryStrategy\";\n\n/**\n * Represents a strategy for querying cookies from a browser\n */\nexport type CookieQueryStrategy =\n  | CompositeCookieQueryStrategy\n  | ChromeCookieQueryStrategy\n  | FirefoxCookieQueryStrategy\n  | SafariCookieQueryStrategy;\n\n/**\n * Factory for creating browser-specific cookie query strategies\n */\nexport const CookieStrategyFactory = {\n  strategies: new Map<string, new () => CookieQueryStrategy>([\n    [\"safari\", SafariCookieQueryStrategy],\n    [\"firefox\", FirefoxCookieQueryStrategy],\n    [\"chrome\", ChromeCookieQueryStrategy],\n  ]),\n\n  /**\n   * Creates a strategy for the specified browser\n   * @param browser - The browser to create a strategy for\n   * @returns A cookie query strategy for the specified browser\n   */\n  createStrategy(browser?: string): CookieQueryStrategy {\n    if (typeof browser !== \"string\") {\n      return new CompositeCookieQueryStrategy([\n        new SafariCookieQueryStrategy(),\n        new FirefoxCookieQueryStrategy(),\n        new ChromeCookieQueryStrategy(),\n      ]);\n    }\n\n    const Strategy = this.strategies.get(browser.toLowerCase());\n    if (Strategy !== undefined) {\n      return new Strategy();\n    }\n\n    return new CompositeCookieQueryStrategy([\n      new SafariCookieQueryStrategy(),\n      new FirefoxCookieQueryStrategy(),\n      new ChromeCookieQueryStrategy(),\n    ]);\n  },\n};\n","import type { CookieSpec, ExportedCookie } from \"../types/schemas\";\nimport { logger } from \"../utils/logHelpers\";\n\nimport { CookieQueryService } from \"./services/CookieQueryService\";\nimport {\n  CookieStrategyFactory,\n  type CookieQueryStrategy,\n} from \"./services/CookieStrategyFactory\";\n\n/**\n * Format a cookie's metadata field if it exists and is of the correct type\n * @param meta - The metadata object\n * @param field - The field name to format\n * @param type - The expected type of the field\n * @returns Formatted string or null\n */\nfunction formatMetaField(\n  meta: Record<string, unknown> | undefined,\n  field: string,\n  type: string,\n): string | null {\n  if (!meta || !(field in meta)) {\n    return null;\n  }\n\n  const value = meta[field];\n  if (typeof value !== type) {\n    return null;\n  }\n\n  const fieldDisplay = field.charAt(0).toUpperCase() + field.slice(1);\n  const displayValue = type === \"number\" ? (value as number) : String(value);\n  return `  ${fieldDisplay}: ${displayValue}`;\n}\n\n/**\n * Format cookie dates\n * @param cookie - The cookie to format dates for\n * @returns Array of formatted date strings\n */\nfunction formatDates(cookie: ExportedCookie): string[] {\n  const lines: string[] = [];\n\n  const creation = cookie.meta?.creation;\n  if (typeof creation === \"number\") {\n    const creationDate = new Date(creation * 1000);\n    lines.push(`  Creation: ${creationDate.toISOString()}`);\n  }\n\n  if (\n    cookie.expiry !== \"Infinity\" &&\n    (typeof cookie.expiry === \"number\" || cookie.expiry instanceof Date)\n  ) {\n    const expiryDate = new Date(cookie.expiry);\n    lines.push(`  Expiry: ${expiryDate.toISOString()}`);\n  }\n\n  return lines;\n}\n\n/**\n * Format a cookie for display\n * @param cookie - The cookie to format\n * @returns Array of formatted lines\n */\nfunction formatCookie(cookie: ExportedCookie): string[] {\n  const lines: string[] = [\n    \"Cookie details:\",\n    `  Name: ${cookie.name}`,\n    `  Domain: ${cookie.domain}`,\n    `  Value: ${cookie.value}`,\n  ];\n\n  const metaFields = [\"path\", \"flags\", \"version\"] as const;\n  for (const field of metaFields) {\n    const formatted = formatMetaField(\n      cookie.meta,\n      field,\n      field === \"path\" ? \"string\" : \"number\",\n    );\n    if (formatted !== null) {\n      lines.push(formatted);\n    }\n  }\n\n  lines.push(...formatDates(cookie));\n  lines.push(\"\");\n  return lines;\n}\n\ninterface QueryOptions {\n  /** Maximum number of cookies to return */\n  limit?: number;\n  /** Whether to remove expired cookies */\n  removeExpired: boolean;\n  /** Optional path to a specific binarycookies store file */\n  store?: string;\n  /** Strategy for querying cookies */\n  strategy: CookieQueryStrategy;\n}\n\n/**\n * Internal function to query cookies and apply limit\n * @param queryService - The query service to use\n * @param specs - Cookie specifications to query\n * @param options - Query options including limit, expiry handling, store path, and strategy\n * @returns Array of cookies\n */\nasync function queryAndLimitCookies(\n  queryService: CookieQueryService,\n  specs: CookieSpec[],\n  options: QueryOptions,\n): Promise<ExportedCookie[]> {\n  let results: ExportedCookie[] = [];\n\n  for (const spec of specs) {\n    const cookies = await queryService.queryCookies(spec, options);\n    results = [...results, ...cookies];\n\n    if (\n      typeof options.limit === \"number\" &&\n      options.limit > 0 &&\n      results.length >= options.limit\n    ) {\n      results = results.slice(0, options.limit);\n      break;\n    }\n  }\n\n  return results;\n}\n\n/**\n * Query cookies from the browser using the specified strategy\n * @param args - Command line arguments including browser and output format options\n * @param cookieSpec - Cookie specification(s) to query for\n * @param limit - Maximum number of cookies to return\n * @param removeExpired - Whether to remove expired cookies\n * @param store - Optional path to a specific binarycookies store file\n */\nexport async function cliQueryCookies(\n  args: Record<string, unknown>,\n  cookieSpec: CookieSpec | CookieSpec[],\n  limit?: number,\n  removeExpired = false,\n  store?: string,\n): Promise<void> {\n  try {\n    const browser = typeof args.browser === \"string\" ? args.browser : undefined;\n    const strategy = CookieStrategyFactory.createStrategy(browser);\n    const queryService = new CookieQueryService(strategy);\n    const specs = Array.isArray(cookieSpec) ? cookieSpec : [cookieSpec];\n\n    const results = await queryAndLimitCookies(queryService, specs, {\n      limit,\n      removeExpired,\n      store,\n      strategy,\n    });\n\n    if (results.length === 0) {\n      logger.error(\"No results\");\n      return;\n    }\n\n    if (args[\"--json\"] === true) {\n      logger.log(JSON.stringify(results, null, 2));\n    } else {\n      results.forEach((cookie: ExportedCookie) => {\n        const lines = formatCookie(cookie);\n        lines.forEach((line) => logger.log(line));\n      });\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.error(error.message);\n    } else {\n      logger.error(\"An unknown error occurred\");\n    }\n  }\n}\n\nfunction formatResults(results: ExportedCookie[]): void {\n  if (results.length === 0) {\n    logger.warn(\"No cookies found matching the specified criteria\");\n    return;\n  }\n\n  logger.log(JSON.stringify(results, null, 2));\n}\n\nfunction formatResultsVerbose(results: ExportedCookie[]): void {\n  if (results.length === 0) {\n    logger.warn(\"No cookies found matching the specified criteria\");\n    return;\n  }\n\n  const lines: string[] = [];\n  results.forEach((cookie) => {\n    lines.push(\"\\n-------------------\");\n    lines.push(`Name: ${cookie.name}`);\n    lines.push(`Domain: ${cookie.domain}`);\n    lines.push(`Value: ${cookie.value}`);\n\n    const path = cookie.meta?.path;\n    if (typeof path === \"string\" && path.length > 0) {\n      lines.push(`Path: ${path}`);\n    }\n\n    const dateLines = formatDates(cookie);\n    lines.push(...dateLines);\n\n    if (cookie.meta) {\n      const metaLines = [\n        formatMetaField(cookie.meta, \"file\", \"string\"),\n        formatMetaField(cookie.meta, \"browser\", \"string\"),\n        formatMetaField(cookie.meta, \"profile\", \"string\"),\n        formatMetaField(cookie.meta, \"decrypted\", \"boolean\"),\n      ].filter((line): line is string => line !== null);\n\n      if (metaLines.length > 0) {\n        lines.push(\"Metadata:\");\n        lines.push(...metaLines);\n      }\n    }\n  });\n\n  lines.forEach((line) => logger.log(line));\n}\n\n/**\n * Query cookies based on the provided specification\n * @param spec - The cookie specification to query\n * @param service - The cookie query service to use\n * @param verbose - Whether to output verbose information\n * @returns Promise that resolves when the query is complete\n */\nexport async function queryCookies(\n  spec: CookieSpec,\n  service: CookieQueryService,\n  verbose = false,\n): Promise<void> {\n  const results = await service.queryCookies(spec);\n  if (verbose) {\n    formatResultsVerbose(results);\n  } else {\n    formatResults(results);\n  }\n}\n","#!/usr/bin/env node\n\n// Local imports - core\nimport { cookieSpecsFromUrl } from \"@core/cookies/cookieSpecsFromUrl\";\nimport { parseArgv } from \"@utils/argv\";\nimport logger from \"@utils/logger\";\n\nimport type { CookieSpec } from \"../types/schemas\";\n\nimport { cliQueryCookies } from \"./cliQueryCookies\";\n\nfunction showHelp(): void {\n  logger.log(`Usage: get-cookie [name] [domain] [options]`);\n  logger.log(`Options:`);\n  logger.log(`  -h, --help: Show this help message`);\n  logger.log(`  -v, --verbose: Enable verbose output`);\n  logger.log(`  -d, --dump: Dump all results`);\n  logger.log(`  -D, --dump-grouped: Dump all results, grouped by profile`);\n  logger.log(`  -r, --render: Render all results`);\n  logger.log(`  -u, --url: URL to extract cookie specs from`);\n  logger.log(`  -n, --name: Cookie name pattern`);\n  logger.log(`  -d, --domain: Cookie domain pattern`);\n  logger.log(`  --store: Path to a specific binarycookies store file`);\n  logger.log(`  --output: Output format (e.g., json)`);\n}\n\nfunction createCookieSpec(name: string, domain: string): CookieSpec {\n  return {\n    name: name || \"%\",\n    domain: domain || \"%\",\n  };\n}\n\nfunction getCookieSpecs(\n  values: Record<string, string | boolean | string[]>,\n  positionals: string[],\n): CookieSpec[] {\n  const url = values.url as string | undefined;\n\n  if (typeof url === \"string\") {\n    const specs = cookieSpecsFromUrl(url);\n    if (!Array.isArray(specs)) {\n      logger.error(\"Invalid cookie specs from URL\");\n      return [];\n    }\n    return specs;\n  }\n\n  const name = (values.name as string) || positionals[0] || \"%\";\n  const domain = (values.domain as string) || positionals[1] || \"%\";\n  return [createCookieSpec(name, domain)];\n}\n\nasync function handleCookieQuery(\n  values: Record<string, string | boolean | string[]>,\n  positionals: string[],\n): Promise<void> {\n  const cookieSpecs = getCookieSpecs(values, positionals);\n\n  if (values.verbose === true) {\n    logger.log(\"cookieSpecs\", cookieSpecs);\n  }\n\n  try {\n    await cliQueryCookies(\n      values,\n      cookieSpecs,\n      undefined,\n      values.removeExpired === true,\n      values.store as string | undefined,\n    );\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.error(\"Error querying cookies:\", error.message);\n    } else {\n      logger.error(\"An unknown error occurred while querying cookies\");\n    }\n  }\n}\n\nasync function main(): Promise<void> {\n  const args = process.argv.slice(2);\n  const { values, positionals } = parseArgv(args);\n\n  if (values.help === true) {\n    showHelp();\n    return;\n  }\n\n  await handleCookieQuery(values, positionals);\n}\n\nmain().catch((error) => {\n  if (error instanceof Error) {\n    logger.error(\"Fatal error:\", error.message);\n  } else {\n    logger.error(\"An unknown fatal error occurred\");\n  }\n  process.exit(1);\n});\n"],"mappings":"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","names":["processDomainsIntoCookieSpecs","domain","parts","cookieSpecs","i","subDomain","cookieSpecsFromUrl","url","urlObj","import_minimist","parseArgv","argv","parsed","minimist","_","values","import_consola","import_os","import_dotenv","import_zod","EnvironmentSchema","val","env","consola","env","isDebug","logger","logger_default","logOperationResult","operation","success","context","logger_default","logError","message","error","errorMessage","logWarn","component","createTaggedLogger","CookieQueryService","strategy","spec","options","import_fs","import_path","import_fast_glob","import_os","import_path","chromeApplicationSupport","home","import_better_sqlite3","openDatabase","file","BetterSqlite3","error","logError","closeDatabase","db","querySqliteThenTransform","sql","params","rowFilter","rowTransform","rows","filteredRows","logger","createTaggedLogger","isValidFilePath","path","trimmedPath","getCookieFiles","patterns","chromeApplicationSupport","files","pattern","matches","glob","buildSqlQuery","name","domain","isWildcard","sql","params","processCookieFile","cookieFile","rows","querySqliteThenTransform","row","logOperationResult","error","logError","getEncryptedChromeCookie","file","cookieFiles","results","cookies","import_fast_glob","logger","createTaggedLogger","listChromeProfilePaths","files","fg","chromeApplicationSupport","import_crypto","freeGlobal","freeGlobal_default","freeSelf","root","freeGlobal_default","root_default","Symbol","root_default","Symbol_default","objectProto","hasOwnProperty","nativeObjectToString","symToStringTag","Symbol_default","getRawTag","value","isOwn","tag","unmasked","result","getRawTag_default","objectProto","nativeObjectToString","objectToString","value","objectToString_default","nullTag","undefinedTag","symToStringTag","Symbol_default","baseGetTag","value","getRawTag_default","objectToString_default","baseGetTag_default","isObject","value","type","isObject_default","asyncTag","funcTag","genTag","proxyTag","isFunction","value","isObject_default","tag","baseGetTag_default","isFunction_default","coreJsData","root_default","coreJsData_default","maskSrcKey","uid","coreJsData_default","isMasked","func","isMasked_default","funcProto","funcToString","toSource","func","toSource_default","reRegExpChar","reIsHostCtor","funcProto","objectProto","funcToString","hasOwnProperty","reIsNative","baseIsNative","value","isObject_default","isMasked_default","pattern","isFunction_default","toSource_default","baseIsNative_default","getValue","object","key","getValue_default","getNative","object","key","value","getValue_default","baseIsNative_default","getNative_default","eq","value","other","eq_default","nativeCreate","getNative_default","nativeCreate_default","hashClear","nativeCreate_default","hashClear_default","hashDelete","key","result","hashDelete_default","HASH_UNDEFINED","objectProto","hasOwnProperty","hashGet","key","data","nativeCreate_default","result","hashGet_default","objectProto","hasOwnProperty","hashHas","key","data","nativeCreate_default","hashHas_default","HASH_UNDEFINED","hashSet","key","value","data","nativeCreate_default","hashSet_default","Hash","entries","index","length","entry","hashClear_default","hashDelete_default","hashGet_default","hashHas_default","hashSet_default","Hash_default","listCacheClear","listCacheClear_default","assocIndexOf","array","key","length","eq_default","assocIndexOf_default","arrayProto","splice","listCacheDelete","key","data","index","assocIndexOf_default","lastIndex","listCacheDelete_default","listCacheGet","key","data","index","assocIndexOf_default","listCacheGet_default","listCacheHas","key","assocIndexOf_default","listCacheHas_default","listCacheSet","key","value","data","index","assocIndexOf_default","listCacheSet_default","ListCache","entries","index","length","entry","listCacheClear_default","listCacheDelete_default","listCacheGet_default","listCacheHas_default","listCacheSet_default","ListCache_default","Map","getNative_default","root_default","Map_default","mapCacheClear","Hash_default","Map_default","ListCache_default","mapCacheClear_default","isKeyable","value","type","isKeyable_default","getMapData","map","key","data","isKeyable_default","getMapData_default","mapCacheDelete","key","result","getMapData_default","mapCacheDelete_default","mapCacheGet","key","getMapData_default","mapCacheGet_default","mapCacheHas","key","getMapData_default","mapCacheHas_default","mapCacheSet","key","value","data","getMapData_default","size","mapCacheSet_default","MapCache","entries","index","length","entry","mapCacheClear_default","mapCacheDelete_default","mapCacheGet_default","mapCacheHas_default","mapCacheSet_default","MapCache_default","FUNC_ERROR_TEXT","memoize","func","resolver","memoized","args","key","cache","result","MapCache_default","memoize_default","removeV10Prefix","memoize_default","value","removePadding","decrypted","padding","extractValue","decodedString","cleanupPatterns","pattern","decrypt","encryptedValue","password","resolve","reject","error","key","iv","decipher","e","import_os","import_child_process","import_util","execPromise","CommandExecutionError","message","command","originalError","execSimple","options","result","error","logError","getChromePassword","execSimple","getChromePassword","getExpiryDate","expiry","createExportedCookie","domain","name","value","file","decrypted","ChromeCookieQueryStrategy","createTaggedLogger","store","cookieFiles","listChromeProfilePaths","files","password","getChromePassword","error","logError","encryptedCookies","getEncryptedChromeCookie","context","cookie","result","decryptedValue","decrypt","flatMapAsync","array","callback","defaultValue","item","CompositeCookieQueryStrategy","strategies","createTaggedLogger","error","strategy","name","domain","store","flatMapAsync","import_os","import_path","import_fast_glob","logger","createTaggedLogger","findFirefoxCookieFiles","home","logWarn","patterns","files","pattern","matches","fg","FirefoxCookieQueryStrategy","name","domain","store","fileList","results","file","cookies","querySqliteThenTransform","row","error","import_os","import_path","import_buffer","import_fs","import_os","import_path","import_buffer","import_destr","import_zod","CookieDomainSchema","domain","CookieNameSchema","name","CookiePathSchema","path","CookieValueSchema","value","destr","BinaryCookieRowSchema","CookieSpecSchema","CookieMetaSchema","ExportedCookieSchema","CookieRowSchema","RenderOptionsSchema","BrowserNameSchema","CookieQueryStrategySchema","logger","createTaggedLogger","BinaryCodableCookie","buffer","container","value","processed","lastProcessed","token","parts","payload","parsed","decoded","jwtPayload","jsonValue","flagsValue","domain","macToUnixOffset","expiryUnix","creationUnix","BinaryCookieRowSchema","offset","end","size","version","hasPort","offsets","expirationBuffer","expiration","creationBuffer","creation","offsetEntries","entry","a","b","e","field","length","baseOffset","logger","createTaggedLogger","_BinaryCodablePage","buffer","container","cookies","cookie","cookieRow","error","errorMessage","logWarn","header","cookieCount","pageStart","cookieOffsets","i","cookieOffset","footer","cookieSize","cookieBuffer","BinaryCodableCookie","BinaryCodablePage","logger","createTaggedLogger","_BinaryCodableCookies","buffer","container","path","cookies","page","pageCookies","error","errorMessage","logWarn","magic","pageCount","pageSizes","i","pageSize","currentOffset","pageBuffer","BinaryCodablePage","checksum","footer","_plistData","BinaryCodableCookies","decodeBinaryCookies","cookieDbPath","BinaryCodableCookies","SafariCookieQueryStrategy","home","domain","expiry","flags","bit","creation","cookieDbPath","name","decodeBinaryCookies","cookie","error","logError","store","CookieStrategyFactory","SafariCookieQueryStrategy","FirefoxCookieQueryStrategy","ChromeCookieQueryStrategy","browser","CompositeCookieQueryStrategy","Strategy","formatMetaField","meta","field","type","value","fieldDisplay","displayValue","formatDates","cookie","lines","creation","creationDate","expiryDate","formatCookie","metaFields","formatted","queryAndLimitCookies","queryService","specs","options","results","spec","cookies","cliQueryCookies","args","cookieSpec","limit","removeExpired","store","browser","strategy","CookieStrategyFactory","CookieQueryService","logger_default","line","error","showHelp","logger_default","createCookieSpec","name","domain","getCookieSpecs","values","positionals","url","specs","cookieSpecsFromUrl","handleCookieQuery","cookieSpecs","cliQueryCookies","error","main","args","parseArgv"]}