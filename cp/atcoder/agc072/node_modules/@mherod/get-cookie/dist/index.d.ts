import { z } from 'zod';

/**
 * Schema for cookie specification parameters
 * Defines the required fields for identifying a cookie
 * @example
 * ```typescript
 * // Validate a cookie specification
 * const spec = {
 *   name: 'session',
 *   domain: 'example.com'
 * };
 * const result = CookieSpecSchema.safeParse(spec);
 * if (result.success) {
 *   logger.info('Valid cookie spec:', result.data);
 * } else {
 *   logger.error('Invalid cookie spec:', result.error);
 * }
 *
 * // Invalid spec (empty name)
 * const invalidSpec = {
 *   name: '',
 *   domain: 'example.com'
 * };
 * // Throws: "Cookie name cannot be empty"
 * CookieSpecSchema.parse(invalidSpec);
 * ```
 */
declare const CookieSpecSchema: z.ZodObject<{
    name: z.ZodEffects<z.ZodString, string, string>;
    domain: z.ZodEffects<z.ZodString, string, string>;
}, "strict", z.ZodTypeAny, {
    name: string;
    domain: string;
}, {
    name: string;
    domain: string;
}>;
/**
 * Type definition for cookie specification
 * Used for specifying which cookie to query
 * @example
 * ```typescript
 * // Basic cookie spec
 * const spec: CookieSpec = {
 *   name: 'auth',
 *   domain: 'api.example.com'
 * };
 *
 * // Use in function parameters
 * function queryCookie(spec: CookieSpec): Promise<ExportedCookie[]> {
 *   return getCookie(spec);
 * }
 *
 * // Array of specs
 * const specs: CookieSpec[] = [
 *   { name: 'session', domain: 'app.example.com' },
 *   { name: 'theme', domain: 'example.com' }
 * ];
 * ```
 */
type CookieSpec = z.infer<typeof CookieSpecSchema>;
/**
 * Schema for exported cookie data
 * Represents a cookie with all its properties and metadata
 * @example
 * ```typescript
 * // Validate an exported cookie
 * const cookie = {
 *   domain: 'example.com',
 *   name: 'session',
 *   value: 'abc123',
 *   expiry: new Date('2024-12-31'),
 *   meta: {
 *     file: '/path/to/cookies.db'
 *   }
 * };
 * const result = ExportedCookieSchema.safeParse(cookie);
 * if (result.success) {
 *   logger.info('Valid cookie:', result.data);
 * } else {
 *   logger.error('Invalid cookie:', result.error);
 * }
 *
 * // Cookie with infinite expiry
 * const infiniteCookie = {
 *   ...cookie,
 *   expiry: "Infinity"
 * };
 * ExportedCookieSchema.parse(infiniteCookie); // OK
 * ```
 */
declare const ExportedCookieSchema: z.ZodObject<{
    domain: z.ZodEffects<z.ZodString, string, string>;
    name: z.ZodEffects<z.ZodString, string, string>;
    value: z.ZodPipeline<z.ZodEffects<z.ZodString, unknown, string>, z.ZodAny>;
    expiry: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"Infinity">, z.ZodDate, z.ZodNumber]>>;
    meta: z.ZodOptional<z.ZodObject<{
        file: z.ZodOptional<z.ZodString>;
        browser: z.ZodOptional<z.ZodString>;
        decrypted: z.ZodOptional<z.ZodBoolean>;
        secure: z.ZodOptional<z.ZodBoolean>;
        httpOnly: z.ZodOptional<z.ZodBoolean>;
        path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
    }, "strict", z.ZodUnknown, z.objectOutputType<{
        file: z.ZodOptional<z.ZodString>;
        browser: z.ZodOptional<z.ZodString>;
        decrypted: z.ZodOptional<z.ZodBoolean>;
        secure: z.ZodOptional<z.ZodBoolean>;
        httpOnly: z.ZodOptional<z.ZodBoolean>;
        path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
    }, z.ZodUnknown, "strict">, z.objectInputType<{
        file: z.ZodOptional<z.ZodString>;
        browser: z.ZodOptional<z.ZodString>;
        decrypted: z.ZodOptional<z.ZodBoolean>;
        secure: z.ZodOptional<z.ZodBoolean>;
        httpOnly: z.ZodOptional<z.ZodBoolean>;
        path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
    }, z.ZodUnknown, "strict">>>;
}, "strict", z.ZodTypeAny, {
    name: string;
    domain: string;
    value?: any;
    expiry?: number | Date | "Infinity" | undefined;
    meta?: z.objectOutputType<{
        file: z.ZodOptional<z.ZodString>;
        browser: z.ZodOptional<z.ZodString>;
        decrypted: z.ZodOptional<z.ZodBoolean>;
        secure: z.ZodOptional<z.ZodBoolean>;
        httpOnly: z.ZodOptional<z.ZodBoolean>;
        path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
    }, z.ZodUnknown, "strict"> | undefined;
}, {
    name: string;
    value: string;
    domain: string;
    expiry?: number | Date | "Infinity" | undefined;
    meta?: z.objectInputType<{
        file: z.ZodOptional<z.ZodString>;
        browser: z.ZodOptional<z.ZodString>;
        decrypted: z.ZodOptional<z.ZodBoolean>;
        secure: z.ZodOptional<z.ZodBoolean>;
        httpOnly: z.ZodOptional<z.ZodBoolean>;
        path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
    }, z.ZodUnknown, "strict"> | undefined;
}>;
/**
 * Type definition for exported cookie data
 * Represents the structure of a cookie after it has been retrieved
 * @example
 * ```typescript
 * // Basic exported cookie
 * const cookie: ExportedCookie = {
 *   domain: 'example.com',
 *   name: 'session',
 *   value: 'abc123',
 *   expiry: new Date('2024-12-31'),
 *   meta: {
 *     file: '/path/to/cookies.db'
 *   }
 * };
 *
 * // Process exported cookies
 * function processCookies(cookies: ExportedCookie[]): string[] {
 *   return cookies.map(cookie => `${cookie.name}=${cookie.value}`);
 * }
 *
 * // Filter expired cookies
 * function filterExpired(cookies: ExportedCookie[]): ExportedCookie[] {
 *   const now = new Date();
 *   return cookies.filter(cookie =>
 *     cookie.expiry === "Infinity" ||
 *     (cookie.expiry instanceof Date && cookie.expiry > now)
 *   );
 * }
 * ```
 */
type ExportedCookie = z.infer<typeof ExportedCookieSchema>;
/**
 * Schema for cookie render options
 */
declare const RenderOptionsSchema: z.ZodObject<{
    format: z.ZodOptional<z.ZodEnum<["merged", "grouped"]>>;
    separator: z.ZodOptional<z.ZodString>;
    showFilePaths: z.ZodOptional<z.ZodBoolean>;
}, "strict", z.ZodTypeAny, {
    format?: "merged" | "grouped" | undefined;
    separator?: string | undefined;
    showFilePaths?: boolean | undefined;
}, {
    format?: "merged" | "grouped" | undefined;
    separator?: string | undefined;
    showFilePaths?: boolean | undefined;
}>;
/**
 * Type definition for render options
 */
type RenderOptions = z.infer<typeof RenderOptionsSchema>;
/**
 * Schema for browser names
 */
declare const BrowserNameSchema: z.ZodEnum<["Chrome", "Firefox", "Safari", "internal", "unknown"]>;
/**
 * Type definition for browser names
 */
type BrowserName = z.infer<typeof BrowserNameSchema>;
/**
 * Schema for cookie query strategy
 */
declare const CookieQueryStrategySchema: z.ZodObject<{
    browserName: z.ZodEnum<["Chrome", "Firefox", "Safari", "internal", "unknown"]>;
    queryCookies: z.ZodFunction<z.ZodTuple<[z.ZodString, z.ZodString, z.ZodOptional<z.ZodString>], z.ZodUnknown>, z.ZodPromise<z.ZodArray<z.ZodObject<{
        domain: z.ZodEffects<z.ZodString, string, string>;
        name: z.ZodEffects<z.ZodString, string, string>;
        value: z.ZodPipeline<z.ZodEffects<z.ZodString, unknown, string>, z.ZodAny>;
        expiry: z.ZodOptional<z.ZodUnion<[z.ZodLiteral<"Infinity">, z.ZodDate, z.ZodNumber]>>;
        meta: z.ZodOptional<z.ZodObject<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, "strict", z.ZodUnknown, z.objectOutputType<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, z.ZodUnknown, "strict">, z.objectInputType<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, z.ZodUnknown, "strict">>>;
    }, "strict", z.ZodTypeAny, {
        name: string;
        domain: string;
        value?: any;
        expiry?: number | Date | "Infinity" | undefined;
        meta?: z.objectOutputType<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, z.ZodUnknown, "strict"> | undefined;
    }, {
        name: string;
        value: string;
        domain: string;
        expiry?: number | Date | "Infinity" | undefined;
        meta?: z.objectInputType<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, z.ZodUnknown, "strict"> | undefined;
    }>, "many">>>;
}, "strict", z.ZodTypeAny, {
    browserName: "unknown" | "Chrome" | "Firefox" | "Safari" | "internal";
    queryCookies: (args_0: string, args_1: string, args_2: string | undefined, ...args: unknown[]) => Promise<{
        name: string;
        domain: string;
        value?: any;
        expiry?: number | Date | "Infinity" | undefined;
        meta?: z.objectOutputType<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, z.ZodUnknown, "strict"> | undefined;
    }[]>;
}, {
    browserName: "unknown" | "Chrome" | "Firefox" | "Safari" | "internal";
    queryCookies: (args_0: string, args_1: string, args_2: string | undefined, ...args: unknown[]) => Promise<{
        name: string;
        value: string;
        domain: string;
        expiry?: number | Date | "Infinity" | undefined;
        meta?: z.objectInputType<{
            file: z.ZodOptional<z.ZodString>;
            browser: z.ZodOptional<z.ZodString>;
            decrypted: z.ZodOptional<z.ZodBoolean>;
            secure: z.ZodOptional<z.ZodBoolean>;
            httpOnly: z.ZodOptional<z.ZodBoolean>;
            path: z.ZodOptional<z.ZodDefault<z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>>>;
        }, z.ZodUnknown, "strict"> | undefined;
    }[]>;
}>;
/**
 * Type definition for cookie query strategy
 */
type CookieQueryStrategy = z.infer<typeof CookieQueryStrategySchema>;
/**
 * Type representing either a single cookie specification or an array of specifications.
 * Useful when you need to query multiple cookies in a single operation.
 * @example
 * ```typescript
 * // Single cookie spec
 * const single: MultiCookieSpec = {
 *   domain: "example.com",
 *   name: "sessionId"
 * };
 *
 * // Multiple cookie specs
 * const multiple: MultiCookieSpec = [
 *   { domain: "example.com", name: "sessionId" },
 *   { domain: "api.example.com", name: "authToken" }
 * ];
 * ```
 */
type MultiCookieSpec = CookieSpec | CookieSpec[];

/**
 * Retrieves browser cookies that match the specified cookie name and domain criteria.
 * This function provides a way to search and filter cookies based on given specifications.
 * @param cookieSpec - The cookie specification containing search criteria
 * @param cookieSpec.name - The name of the cookie to search for
 * @param cookieSpec.domain - (optional) The domain to filter cookies by
 * @returns An array of ExportedCookie objects that match the specification
 * @throws Will catch and handle any errors during cookie querying, logging a warning
 * to the console without throwing to the caller
 * @example
 * ```typescript
 * import { getCookie } from "@mherod/get-cookie";
 *
 * // Get all cookies named "sessionId"
 * const cookies = await getCookie({ name: "sessionId" });
 * // Returns: [{ name: "sessionId", value: "abc123", domain: ".example.com", ... }]
 *
 * // Get cookies named "userPref" from specific domain
 * const domainCookies = await getCookie({
 *   name: "userPref",
 *   domain: "example.com"
 * });
 * // Returns: [{ name: "userPref", value: "darkMode", domain: "example.com", ... }]
 * ```
 */
declare function getCookie(cookieSpec: CookieSpec): Promise<ExportedCookie[]>;

/**
 * Retrieves cookies from Chrome browser storage that match the specified criteria.
 * @param cookieSpec - The cookie specification containing search criteria
 * @param cookieSpec.name - The name of the cookie to search for
 * @param cookieSpec.domain - (optional) The domain to filter cookies by
 * @returns An array of ExportedCookie objects that match the specification
 * @throws Will catch and handle any errors during cookie querying, logging a warning
 * to the console without throwing to the caller
 * @example
 * ```typescript
 * import { getChromeCookie } from "@mherod/get-cookie";
 *
 * // Get all cookies named "sessionId" from Chrome
 * const cookies = await getChromeCookie({ name: "sessionId" });
 *
 * // Get cookies named "userPref" from specific domain in Chrome
 * const domainCookies = await getChromeCookie({
 *   name: "userPref",
 *   domain: "example.com"
 * });
 * ```
 */
declare function getChromeCookie(cookieSpec: CookieSpec): Promise<ExportedCookie[]>;

/**
 * Retrieves cookies from Firefox browser storage that match the specified criteria.
 * @param cookieSpec - The cookie specification containing search criteria
 * @param cookieSpec.name - The name of the cookie to search for
 * @param cookieSpec.domain - (optional) The domain to filter cookies by
 * @returns An array of ExportedCookie objects that match the specification
 * @throws Will catch and handle any errors during cookie querying, logging a warning
 * to the console without throwing to the caller
 * @example
 * ```typescript
 * import { getFirefoxCookie } from "@mherod/get-cookie";
 *
 * // Get all cookies named "sessionId" from Firefox
 * const cookies = await getFirefoxCookie({ name: "sessionId" });
 *
 * // Get cookies named "userPref" from specific domain in Firefox
 * const domainCookies = await getFirefoxCookie({
 *   name: "userPref",
 *   domain: "example.com"
 * });
 * ```
 */
declare function getFirefoxCookie(cookieSpec: CookieSpec): Promise<ExportedCookie[]>;

/**
 * Retrieves and renders cookies in a grouped format based on their source files.
 * @param cookieSpec - The cookie specification containing search criteria
 * @param cookieSpec.name - The name of the cookie to search for
 * @param cookieSpec.domain - (optional) The domain to filter cookies by
 * @param options - Options for rendering the cookies
 * @param options.showFilePaths - Whether to include file paths in the output
 * @param options.separator - Custom separator for cookie values
 * @returns An array of strings, each representing a group of cookies from a source file
 * @example
 * ```typescript
 * // Basic usage - get all cookies named "sessionId" grouped by source file
 * const cookies = await getGroupedRenderedCookies({ name: "sessionId" });
 *
 * // Get cookies with domain filter and custom rendering options
 * const domainCookies = await getGroupedRenderedCookies(
 *   {
 *     name: "userPref",
 *     domain: "example.com"
 *   },
 *   {
 *     showFilePaths: true,
 *     separator: " | "
 *   }
 * );
 * ```
 */
declare function getGroupedRenderedCookies(cookieSpec: CookieSpec, options?: Omit<RenderOptions, "format">): Promise<string[]>;

/**
 * Retrieves and renders cookies in a merged format
 * @param cookieSpec - The cookie specification to query
 * @param options - Optional rendering options
 * @returns Promise resolving to rendered cookie string
 * @example
 * ```typescript
 * const cookieString = await getMergedRenderedCookies(
 *   { name: 'session', domain: 'example.com' },
 *   { separator: '; ' }
 * );
 * console.log(cookieString); // "session=abc123; auth=xyz789"
 * ```
 */
declare function getMergedRenderedCookies(cookieSpec: CookieSpec, options?: Omit<RenderOptions, "format">): Promise<string>;

export { type BrowserName, type CookieQueryStrategy, type CookieSpec, type ExportedCookie, type MultiCookieSpec, type RenderOptions, getChromeCookie, getCookie, getFirefoxCookie, getGroupedRenderedCookies, getMergedRenderedCookies };
